datasource db {
  provider = "mongodb"
  url      = env("MONGODB_URL")
}

generator client {
  provider = "prisma-client-js"
  output   = "../node_modules/.prisma/client"
}

model Message {
  id          String       @id @default(auto()) @map("_id") @db.ObjectId
  channelId   String
  authorId    String
  spans       Span[]
  attachments Attachment[]
  reactions   Reaction[]
  sentAt      DateTime     @default(now())
  editedAt    DateTime?
  deletedAt   DateTime?
  mentions    Mention[] // Denormalized for fast querying
}

model User {
  id             String       @id @default(auto()) @map("_id") @db.ObjectId
  username       String       @unique
  email          String?      @unique
  verified       Boolean      @default(false)
  hashedPassword String
  memberships    Membership[] @relation("UserMemberships")
  role           InstanceRole @default(USER)
  createdAt      DateTime     @default(now())
  avatarUrl      String?
  lastSeen       DateTime?
  displayName    String?

  InstanceInvite InstanceInvite[]

  UserRoles UserRoles[]

  RefreshToken RefreshToken[]
}

model RefreshToken {
  id         String   @id @default(auto()) @map("_id") @db.ObjectId
  userId     String   @db.ObjectId
  tokenHash  String
  createdAt  DateTime @default(now())
  expiresAt  DateTime
  user       User     @relation(fields: [userId], references: [id])
}

model InstanceInvite {
  id                 String    @id @default(auto()) @map("_id") @db.ObjectId
  code               String    @unique
  createdById        String?   @db.ObjectId
  createdBy          User?     @relation(fields: [createdById], references: [id])
  defaultCommunityId String[]  @db.ObjectId
  maxUses            Int?
  uses               Int       @default(0)
  validUntil         DateTime?
  createdAt          DateTime  @default(now())
  usedByIds          String[]  @db.ObjectId
  disabled           Boolean   @default(false)
}

model Membership {
  id          String    @id @default(auto()) @map("_id") @db.ObjectId
  user        User      @relation("UserMemberships", fields: [userId], references: [id])
  community   Community @relation("CommunityMemberships", fields: [communityId], references: [id])
  joinedAt    DateTime  @default(now())
  userId      String    @db.ObjectId
  communityId String    @db.ObjectId

  @@unique([userId, communityId])
}

model Community {
  id          String       @id @default(auto()) @map("_id") @db.ObjectId
  name        String
  memberships Membership[] @relation("CommunityMemberships")
  channels    Channel[]
  createdAt   DateTime     @default(now())

  UserRoles UserRoles[]

  @@unique([name])
}

model Channel {
  id          String      @id @default(auto()) @map("_id") @db.ObjectId
  name        String
  communityId String      @db.ObjectId
  community   Community?  @relation(fields: [communityId], references: [id])
  createdAt   DateTime    @default(now())
  type        ChannelType @default(TEXT)

  @@unique([communityId, name])
}

model AliasGroup {
  id          String             @id @default(auto()) @map("_id") @db.ObjectId
  name        String
  communityId String             @db.ObjectId
  members     AliasGroupMember[] @relation(fields: [], references: [])
  createdAt   DateTime           @default(now())

  @@unique([communityId, name])
}

model AliasGroupMember {
  id           String      @id @default(auto()) @map("_id") @db.ObjectId
  aliasGroupId String      @db.ObjectId
  userId       String      @db.ObjectId
  aliasGroup   AliasGroup? @relation(fields: [aliasGroupId], references: [id])
}

model Role {
  id        String        @id @default(auto()) @map("_id") @db.ObjectId
  name      String
  actions   RbacActions[] @default([])
  createdAt DateTime      @default(now())

  UserRoles UserRoles[]

  @@unique([name])
}

model UserRoles {
  id             String     @id @default(auto()) @map("_id") @db.ObjectId
  // This is the same relationship as Membership, but it simplifies the auth lookup since our token only has the userId
  userId         String     @db.ObjectId
  communityId    String?    @db.ObjectId
  roleId         String     @db.ObjectId
  isInstanceRole Boolean    @default(false)
  user           User       @relation(fields: [userId], references: [id])
  community      Community? @relation(fields: [communityId], references: [id])
  role           Role       @relation(fields: [roleId], references: [id])

  @@unique([userId, communityId, roleId])
}

enum ChannelType {
  TEXT
  VOICE
  VIDEO
}

enum RbacActions {
  // These are just a bunch I randomly thought of but we'll modify this as we go
  DELETE_MESSAGE
  DELETE_CHANNEL
  DELETE_COMMUNITY
  DELETE_INVITE
  DELETE_USER
  DELETE_ROLE
  DELETE_ALIAS_GROUP
  DELETE_ALIAS_GROUP_MEMBER
  DELETE_INSTANCE_INVITE
  DELETE_MEMBER
  DELETE_REACTION
  DELETE_ATTACHMENT
  CREATE_MESSAGE
  CREATE_CHANNEL
  CREATE_COMMUNITY
  CREATE_INVITE
  CREATE_USER
  CREATE_ROLE
  CREATE_ALIAS_GROUP
  CREATE_ALIAS_GROUP_MEMBER
  CREATE_INSTANCE_INVITE
  CREATE_MEMBER
  CREATE_REACTION
  CREATE_ATTACHMENT
  READ_MESSAGE
  READ_CHANNEL
  READ_COMMUNITY
  READ_USER
  READ_ROLE
  READ_ALIAS_GROUP
  READ_ALIAS_GROUP_MEMBER
  READ_INSTANCE_INVITE
  READ_MEMBER
  UPDATE_COMMUNITY
  UPDATE_USER
  UPDATE_ROLE
  UPDATE_ALIAS_GROUP
  UPDATE_ALIAS_GROUP_MEMBER
  UPDATE_INSTANCE_INVITE
  UPDATE_MEMBER
}

enum InstanceRole {
  OWNER
  USER
}

type Span {
  type        SpanType
  text        String?
  userId      String? // For USER_MENTION
  specialKind String? // For SPECIAL_MENTION: "here", "everyone", etc
  channelId   String? // For CHANNEL_MENTION
  communityId String? // For COMMUNITY_MENTION
  aliasId     String? // For ALIAS_MENTION
}

// New enum with more mention types
enum SpanType {
  PLAINTEXT
  USER_MENTION
  SPECIAL_MENTION
  CHANNEL_MENTION
  COMMUNITY_MENTION
  ALIAS_MENTION
}

type Attachment {
  url      String
  filename String
  filetype String
  size     Int
}

type Reaction {
  emoji   String
  userIds String[]
}

// Mentions array denormalized for notifications/etc
type Mention {
  userId      String?
  specialKind String?
  channelId   String?
  communityId String?
  aliasId     String?
}
