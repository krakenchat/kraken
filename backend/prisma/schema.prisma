datasource db {
  provider = "mongodb"
  url      = env("MONGODB_URL")
}

generator client {
  provider      = "prisma-client-js"
  output        = "../node_modules/.prisma/client"
  binaryTargets = ["native", "linux-musl-openssl-3.0.x"]
}

model Message {
  id                   String     @id @default(auto()) @map("_id") @db.ObjectId
  channelId            String?    @db.ObjectId // Now optional, for DMs
  directMessageGroupId String?    @db.ObjectId // New, for DMs
  authorId             String
  spans                Span[]
  reactions            Reaction[]
  sentAt               DateTime   @default(now())
  editedAt             DateTime?
  deletedAt            DateTime?
  attachments          String[]   @db.ObjectId
  pendingAttachments   Int?       @default(0) // Count of files currently uploading
  searchText           String? // Flattened text from spans for searching

  // Pinning fields
  pinned   Boolean   @default(false)
  pinnedAt DateTime?
  pinnedBy String?   @db.ObjectId

  // Moderation fields (for soft delete by mods)
  deletedBy       String? @db.ObjectId // Who deleted the message (null if author)
  deletedByReason String? // Reason for mod deletion

  channel            Channel?            @relation(fields: [channelId], references: [id], onDelete: Cascade)
  directMessageGroup DirectMessageGroup? @relation("DirectMessageGroupMessages", fields: [directMessageGroupId], references: [id], onDelete: Cascade)
  notifications      Notification[]

  @@index([channelId, searchText])
  @@index([directMessageGroupId, searchText])
  @@index([channelId, pinned]) // For fetching pinned messages in a channel
}

model ReadReceipt {
  id                   String   @id @default(auto()) @map("_id") @db.ObjectId
  userId               String   @db.ObjectId
  channelId            String?  @db.ObjectId // For channel messages
  directMessageGroupId String?  @db.ObjectId // For DM messages
  lastReadMessageId    String   @db.ObjectId // Watermark - last message the user has read
  lastReadAt           DateTime @default(now())

  user               User?               @relation("UserReadReceipts", fields: [userId], references: [id], onDelete: Cascade)
  channel            Channel?            @relation("ChannelReadReceipts", fields: [channelId], references: [id], onDelete: Cascade)
  directMessageGroup DirectMessageGroup? @relation("DirectMessageGroupReadReceipts", fields: [directMessageGroupId], references: [id], onDelete: Cascade)

  @@unique([userId, channelId])
  @@unique([userId, directMessageGroupId])
  @@index([userId]) // For fetching all read receipts for a user
  @@index([channelId]) // For channel-specific queries
  @@index([directMessageGroupId]) // For DM-specific queries
}

model Notification {
  id                   String           @id @default(auto()) @map("_id") @db.ObjectId
  userId               String           @db.ObjectId
  type                 NotificationType
  messageId            String?          @db.ObjectId
  channelId            String?          @db.ObjectId
  directMessageGroupId String?          @db.ObjectId
  authorId             String           @db.ObjectId // Who triggered the notification
  read                 Boolean          @default(false)
  dismissed            Boolean          @default(false)
  createdAt            DateTime         @default(now())

  user    User     @relation("UserNotifications", fields: [userId], references: [id], onDelete: Cascade)
  message Message? @relation(fields: [messageId], references: [id], onDelete: Cascade)
  author  User     @relation("NotificationAuthors", fields: [authorId], references: [id], onDelete: Cascade)
  channel Channel? @relation("ChannelNotifications", fields: [channelId], references: [id], onDelete: Cascade)

  @@index([userId, read]) // Fast query for unread notifications
  @@index([userId, createdAt]) // For notification history with pagination
}

model UserNotificationSettings {
  id                  String   @id @default(auto()) @map("_id") @db.ObjectId
  userId              String   @unique @db.ObjectId
  desktopEnabled      Boolean  @default(true)
  playSound           Boolean  @default(true)
  soundType           String   @default("default") // "default", "mention", "dm"
  doNotDisturb        Boolean  @default(false)
  dndStartTime        String? // "22:00" - 24-hour format
  dndEndTime          String? // "08:00" - 24-hour format
  defaultChannelLevel String   @default("mentions") // 'all' | 'mentions' | 'none'
  dmNotifications     Boolean  @default(true)
  createdAt           DateTime @default(now())
  updatedAt           DateTime @updatedAt

  user User @relation("UserNotificationSettings", fields: [userId], references: [id], onDelete: Cascade)
}

model ChannelNotificationOverride {
  id        String   @id @default(auto()) @map("_id") @db.ObjectId
  userId    String   @db.ObjectId
  channelId String   @db.ObjectId
  level     String // 'all' | 'mentions' | 'none'
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user    User    @relation("ChannelNotificationOverrides", fields: [userId], references: [id], onDelete: Cascade)
  channel Channel @relation("ChannelNotificationOverrides", fields: [channelId], references: [id], onDelete: Cascade)

  @@unique([userId, channelId])
  @@index([userId]) // Fast lookup for user's overrides
}

model User {
  id             String       @id @default(auto()) @map("_id") @db.ObjectId
  username       String       @unique
  email          String?      @unique
  verified       Boolean      @default(false)
  hashedPassword String
  memberships    Membership[] @relation("UserMemberships")
  role           InstanceRole @default(USER)
  createdAt      DateTime     @default(now())
  avatarUrl      String?
  bannerUrl      String?
  lastSeen       DateTime?
  displayName    String?

  // Ban status
  banned     Boolean   @default(false)
  bannedAt   DateTime?
  bannedById String?   @db.ObjectId
  bannedBy   User?     @relation("BannedByUser", fields: [bannedById], references: [id], onDelete: NoAction, onUpdate: NoAction)
  bannedUsers User[]   @relation("BannedByUser")

  InstanceInvite InstanceInvite[]

  UserRoles UserRoles[]

  RefreshToken RefreshToken[]

  directMessageGroupMemberships DirectMessageGroupMember[]
  friendshipsA                  Friendship[]               @relation("FriendshipA")
  friendshipsB                  Friendship[]               @relation("FriendshipB")

  ChannelMembership ChannelMembership[] @relation("UserChannelMemberships")
  File              File[]
  ReadReceipts      ReadReceipt[]       @relation("UserReadReceipts")

  // Notification relations
  notifications                Notification[]                @relation("UserNotifications")
  authoredNotifications        Notification[]                @relation("NotificationAuthors")
  notificationSettings         UserNotificationSettings?     @relation("UserNotificationSettings")
  channelNotificationOverrides ChannelNotificationOverride[] @relation("ChannelNotificationOverrides")

  // Replay buffer relations
  egressSessions EgressSession[]
  replayClips    ReplayClip[]

  // Push notification subscriptions
  pushSubscriptions PushSubscription[] @relation("UserPushSubscriptions")
}

model RefreshToken {
  id        String   @id @default(auto()) @map("_id") @db.ObjectId
  userId    String   @db.ObjectId
  tokenHash String
  createdAt DateTime @default(now())
  expiresAt DateTime
  user      User     @relation(fields: [userId], references: [id])
}

model InstanceInvite {
  id                 String    @id @default(auto()) @map("_id") @db.ObjectId
  code               String    @unique
  createdById        String?   @db.ObjectId
  createdBy          User?     @relation(fields: [createdById], references: [id])
  defaultCommunityId String[]  @db.ObjectId
  maxUses            Int?
  uses               Int       @default(0)
  validUntil         DateTime?
  createdAt          DateTime  @default(now())
  usedByIds          String[]  @db.ObjectId
  disabled           Boolean   @default(false)
}

model InstanceSettings {
  id               String             @id @default(auto()) @map("_id") @db.ObjectId
  name             String             @default("Kraken")
  description      String?
  registrationMode RegistrationMode   @default(INVITE_ONLY)
  createdAt        DateTime           @default(now())
  updatedAt        DateTime           @updatedAt
}

enum RegistrationMode {
  OPEN        // Anyone can register
  INVITE_ONLY // Requires an invite code
  CLOSED      // Registration disabled
}

model Membership {
  id          String    @id @default(auto()) @map("_id") @db.ObjectId
  user        User      @relation("UserMemberships", fields: [userId], references: [id])
  community   Community @relation("CommunityMemberships", fields: [communityId], references: [id])
  joinedAt    DateTime  @default(now())
  userId      String    @db.ObjectId
  communityId String    @db.ObjectId

  @@unique([userId, communityId])
}

model Community {
  id          String       @id @default(auto()) @map("_id") @db.ObjectId
  name        String
  memberships Membership[] @relation("CommunityMemberships")
  channels    Channel[]
  createdAt   DateTime     @default(now())
  avatar      String?
  banner      String?
  description String?
  UserRoles   UserRoles[]

  // Moderation relations
  bans           CommunityBan[]     @relation("CommunityBans")
  timeouts       CommunityTimeout[] @relation("CommunityTimeouts")
  moderationLogs ModerationLog[]    @relation("ModerationLogs")

  @@unique([name])
}

model Channel {
  id                    String                        @id @default(auto()) @map("_id") @db.ObjectId
  name                  String
  communityId           String                        @db.ObjectId
  community             Community?                    @relation(fields: [communityId], references: [id], onDelete: Cascade)
  createdAt             DateTime                      @default(now())
  type                  ChannelType                   @default(TEXT)
  position              Int                           @default(0)
  Message               Message[]
  ChannelMembership     ChannelMembership[]           @relation("ChannelMembership")
  isPrivate             Boolean                       @default(false)
  ReadReceipts          ReadReceipt[]                 @relation("ChannelReadReceipts")
  notificationOverrides ChannelNotificationOverride[] @relation("ChannelNotificationOverrides")
  notifications         Notification[]                @relation("ChannelNotifications")

  @@unique([communityId, name])
  @@index([communityId, type, position])
}

model ChannelMembership {
  id        String   @id @default(auto()) @map("_id") @db.ObjectId
  user      User     @relation("UserChannelMemberships", fields: [userId], references: [id], onDelete: Cascade)
  channel   Channel  @relation("ChannelMembership", fields: [channelId], references: [id], onDelete: Cascade)
  joinedAt  DateTime @default(now())
  userId    String   @db.ObjectId
  channelId String   @db.ObjectId
  addedBy   String?  @db.ObjectId // Who added this user (for private channels)

  @@unique([userId, channelId])
}

model AliasGroup {
  id          String             @id @default(auto()) @map("_id") @db.ObjectId
  name        String
  communityId String             @db.ObjectId
  members     AliasGroupMember[] @relation(fields: [], references: [])
  createdAt   DateTime           @default(now())

  @@unique([communityId, name])
}

model AliasGroupMember {
  id           String      @id @default(auto()) @map("_id") @db.ObjectId
  aliasGroupId String      @db.ObjectId
  userId       String      @db.ObjectId
  aliasGroup   AliasGroup? @relation(fields: [aliasGroupId], references: [id])
}

model Role {
  id        String        @id @default(auto()) @map("_id") @db.ObjectId
  name      String
  actions   RbacActions[] @default([])
  createdAt DateTime      @default(now())

  UserRoles UserRoles[]

  @@unique([name])
}

model UserRoles {
  id             String     @id @default(auto()) @map("_id") @db.ObjectId
  // This is the same relationship as Membership, but it simplifies the auth lookup since our token only has the userId
  userId         String     @db.ObjectId
  communityId    String?    @db.ObjectId
  roleId         String     @db.ObjectId
  isInstanceRole Boolean    @default(false)
  user           User       @relation(fields: [userId], references: [id], onDelete: Cascade)
  community      Community? @relation(fields: [communityId], references: [id], onDelete: Cascade)
  role           Role       @relation(fields: [roleId], references: [id], onDelete: Cascade)

  @@unique([userId, communityId, roleId])
}

model DirectMessageGroup {
  id           String                     @id @default(auto()) @map("_id") @db.ObjectId
  name         String? // Optional, for group DMs
  members      DirectMessageGroupMember[]
  createdAt    DateTime                   @default(now())
  messages     Message[]                  @relation("DirectMessageGroupMessages")
  isGroup      Boolean                    @default(false) // true for group DMs, false for 1:1
  ReadReceipts ReadReceipt[]              @relation("DirectMessageGroupReadReceipts")
}

model DirectMessageGroupMember {
  id       String             @id @default(auto()) @map("_id") @db.ObjectId
  groupId  String             @db.ObjectId
  userId   String             @db.ObjectId
  group    DirectMessageGroup @relation(fields: [groupId], references: [id], onDelete: Cascade)
  user     User               @relation(fields: [userId], references: [id], onDelete: Cascade)
  joinedAt DateTime           @default(now())

  @@unique([groupId, userId])
}

model Friendship {
  id        String           @id @default(auto()) @map("_id") @db.ObjectId
  userAId   String           @db.ObjectId
  userBId   String           @db.ObjectId
  createdAt DateTime         @default(now())
  status    FriendshipStatus @default(PENDING)
  userA     User             @relation("FriendshipA", fields: [userAId], references: [id], onDelete: Cascade)
  userB     User             @relation("FriendshipB", fields: [userBId], references: [id], onDelete: Cascade)

  @@unique([userAId, userBId])
}

model File {
  id           String       @id @default(auto()) @map("_id") @db.ObjectId
  filename     String // Original filename
  mimeType     String // MIME type (image/jpeg, etc.)
  fileType     FileType // Enum for different file types
  size         Int // File size in bytes
  checksum     String // SHA-256 hash for integrity
  uploadedBy   User?        @relation(fields: [uploadedById], references: [id])
  uploadedById String?      @db.ObjectId
  uploadedAt   DateTime     @default(now())
  deletedAt    DateTime? // Soft delete
  resourceType ResourceType
  resourceId   String? // ID of the resource this file is associated with (userId, communityId, messageId, etc.)

  // Storage configuration
  storageType StorageType @default(LOCAL)
  storagePath String // Local path or cloud key

  // Relations
  replayClips ReplayClip[]

  @@index([uploadedById]) // show my files or files for specific user
  @@index([deletedAt]) // For cleaning up deleted files
  @@index([resourceType, resourceId]) // For fetching files related to a specific resource
}

model EgressSession {
  id          String    @id @default(auto()) @map("_id") @db.ObjectId
  egressId    String    @unique // LiveKit egress ID
  userId      String    @db.ObjectId
  user        User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  roomName    String // LiveKit room name (channel ID)
  channelId   String    @db.ObjectId // Voice channel ID
  segmentPath String // Path to segments (for cleanup)
  status      String // "active", "stopped", "failed"
  error       String? // Error message if egress failed
  startedAt   DateTime
  endedAt     DateTime?
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt

  @@index([userId, status])
  @@index([status, createdAt])
}

model ReplayClip {
  id              String   @id @default(auto()) @map("_id") @db.ObjectId
  userId          String   @db.ObjectId
  user            User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  fileId          String   @db.ObjectId
  file            File     @relation(fields: [fileId], references: [id], onDelete: Cascade)
  channelId       String?  @db.ObjectId // Optional: which channel it was captured from
  durationSeconds Int // Duration of the clip in seconds
  isPublic        Boolean  @default(false) // Show on user's public profile
  capturedAt      DateTime @default(now())

  @@index([userId, capturedAt])
}

model CommunityBan {
  id          String    @id @default(auto()) @map("_id") @db.ObjectId
  communityId String    @db.ObjectId
  userId      String    @db.ObjectId
  moderatorId String    @db.ObjectId
  reason      String?
  createdAt   DateTime  @default(now())
  expiresAt   DateTime? // null = permanent ban
  active      Boolean   @default(true)

  community Community @relation("CommunityBans", fields: [communityId], references: [id], onDelete: Cascade)

  @@unique([communityId, userId])
  @@index([communityId, active])
}

model CommunityTimeout {
  id          String   @id @default(auto()) @map("_id") @db.ObjectId
  communityId String   @db.ObjectId
  userId      String   @db.ObjectId
  moderatorId String   @db.ObjectId
  reason      String?
  createdAt   DateTime @default(now())
  expiresAt   DateTime // Required - timeouts are always temporary

  community Community @relation("CommunityTimeouts", fields: [communityId], references: [id], onDelete: Cascade)

  @@unique([communityId, userId])
  @@index([communityId, expiresAt])
}

model ModerationLog {
  id              String           @id @default(auto()) @map("_id") @db.ObjectId
  communityId     String           @db.ObjectId
  moderatorId     String           @db.ObjectId
  targetUserId    String?          @db.ObjectId
  targetMessageId String?          @db.ObjectId
  action          ModerationAction
  reason          String?
  metadata        Json?
  createdAt       DateTime         @default(now())

  community Community @relation("ModerationLogs", fields: [communityId], references: [id], onDelete: Cascade)

  @@index([communityId, createdAt])
}

enum FileType {
  IMAGE
  VIDEO
  AUDIO
  DOCUMENT
  OTHER
}

enum ResourceType {
  USER_AVATAR
  USER_BANNER
  COMMUNITY_BANNER
  COMMUNITY_AVATAR
  MESSAGE_ATTACHMENT
  CUSTOM_EMOJI
  REPLAY_CLIP
}

enum StorageType {
  LOCAL
  S3
  AZURE_BLOB
}

enum FriendshipStatus {
  PENDING
  ACCEPTED
  BLOCKED
}

enum ChannelType {
  TEXT
  VOICE
}

enum RbacActions {
  // These are just a bunch I randomly thought of but we'll modify this as we go
  DELETE_MESSAGE
  DELETE_CHANNEL
  DELETE_COMMUNITY
  DELETE_INVITE
  DELETE_USER
  DELETE_ROLE
  DELETE_ALIAS_GROUP
  DELETE_ALIAS_GROUP_MEMBER
  DELETE_INSTANCE_INVITE
  DELETE_MEMBER
  DELETE_REACTION
  CREATE_MESSAGE
  CREATE_CHANNEL
  CREATE_COMMUNITY
  CREATE_INVITE
  CREATE_USER
  CREATE_ROLE
  CREATE_ALIAS_GROUP
  CREATE_ALIAS_GROUP_MEMBER
  CREATE_INSTANCE_INVITE
  CREATE_MEMBER
  CREATE_REACTION
  JOIN_CHANNEL
  READ_MESSAGE
  READ_CHANNEL
  READ_COMMUNITY
  READ_ALL_COMMUNITIES // TODO: we need to rethink this
  READ_USER
  READ_ROLE
  READ_ALIAS_GROUP
  READ_ALIAS_GROUP_MEMBER
  READ_INSTANCE_INVITE
  READ_MEMBER
  UPDATE_COMMUNITY
  UPDATE_CHANNEL
  UPDATE_MESSAGE
  UPDATE_USER
  UPDATE_ROLE
  UPDATE_ALIAS_GROUP
  UPDATE_ALIAS_GROUP_MEMBER
  UPDATE_INSTANCE_INVITE
  UPDATE_MEMBER
  CAPTURE_REPLAY
  // Instance administration
  READ_INSTANCE_SETTINGS
  UPDATE_INSTANCE_SETTINGS
  READ_INSTANCE_STATS
  BAN_USER
  // Community moderation
  KICK_USER
  TIMEOUT_USER
  UNBAN_USER
  PIN_MESSAGE
  UNPIN_MESSAGE
  DELETE_ANY_MESSAGE
  VIEW_BAN_LIST
  VIEW_MODERATION_LOGS
}

enum InstanceRole {
  OWNER
  USER
}

enum ModerationAction {
  BAN_USER
  UNBAN_USER
  KICK_USER
  TIMEOUT_USER
  REMOVE_TIMEOUT
  DELETE_MESSAGE
  PIN_MESSAGE
  UNPIN_MESSAGE
}

enum NotificationType {
  USER_MENTION
  SPECIAL_MENTION
  DIRECT_MESSAGE
  CHANNEL_MESSAGE
}

model PushSubscription {
  id        String   @id @default(auto()) @map("_id") @db.ObjectId
  userId    String   @db.ObjectId
  endpoint  String   @unique
  keys      Json     // { p256dh, auth }
  userAgent String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user User @relation("UserPushSubscriptions", fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
}

type Span {
  type        SpanType
  text        String?
  userId      String? // For USER_MENTION
  specialKind String? // For SPECIAL_MENTION: "here", "channel"
  communityId String? // For COMMUNITY_MENTION
  aliasId     String? // For ALIAS_MENTION
}

// New enum with more mention types
enum SpanType {
  PLAINTEXT
  USER_MENTION
  SPECIAL_MENTION
  COMMUNITY_MENTION
  ALIAS_MENTION
}

type Reaction {
  emoji   String
  userIds String[]
}
