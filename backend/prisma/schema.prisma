datasource db {
  provider = "mongodb"
  url      = env("MONGODB_URL")
}

generator client {
  provider = "prisma-client-js"
  output   = "../node_modules/.prisma/client"
}

model Message {
  id                   String     @id @default(auto()) @map("_id") @db.ObjectId
  channelId            String?    @db.ObjectId // Now optional, for DMs
  directMessageGroupId String?    @db.ObjectId // New, for DMs
  authorId             String
  spans                Span[]
  reactions            Reaction[]
  sentAt               DateTime   @default(now())
  editedAt             DateTime?
  deletedAt            DateTime?
  attachments          String[]   @db.ObjectId
  pendingAttachments   Int?       @default(0) // Count of files currently uploading

  channel            Channel?            @relation(fields: [channelId], references: [id], onDelete: Cascade)
  directMessageGroup DirectMessageGroup? @relation("DirectMessageGroupMessages", fields: [directMessageGroupId], references: [id], onDelete: Cascade)
}

model User {
  id             String       @id @default(auto()) @map("_id") @db.ObjectId
  username       String       @unique
  email          String?      @unique
  verified       Boolean      @default(false)
  hashedPassword String
  memberships    Membership[] @relation("UserMemberships")
  role           InstanceRole @default(USER)
  createdAt      DateTime     @default(now())
  avatarUrl      String?
  lastSeen       DateTime?
  displayName    String?

  InstanceInvite InstanceInvite[]

  UserRoles UserRoles[]

  RefreshToken RefreshToken[]

  directMessageGroupMemberships DirectMessageGroupMember[]
  friendshipsA                  Friendship[]               @relation("FriendshipA")
  friendshipsB                  Friendship[]               @relation("FriendshipB")

  ChannelMembership ChannelMembership[] @relation("UserChannelMemberships")
  File              File[]
}

model RefreshToken {
  id        String   @id @default(auto()) @map("_id") @db.ObjectId
  userId    String   @db.ObjectId
  tokenHash String
  createdAt DateTime @default(now())
  expiresAt DateTime
  user      User     @relation(fields: [userId], references: [id])
}

model InstanceInvite {
  id                 String    @id @default(auto()) @map("_id") @db.ObjectId
  code               String    @unique
  createdById        String?   @db.ObjectId
  createdBy          User?     @relation(fields: [createdById], references: [id])
  defaultCommunityId String[]  @db.ObjectId
  maxUses            Int?
  uses               Int       @default(0)
  validUntil         DateTime?
  createdAt          DateTime  @default(now())
  usedByIds          String[]  @db.ObjectId
  disabled           Boolean   @default(false)
}

model Membership {
  id          String    @id @default(auto()) @map("_id") @db.ObjectId
  user        User      @relation("UserMemberships", fields: [userId], references: [id])
  community   Community @relation("CommunityMemberships", fields: [communityId], references: [id])
  joinedAt    DateTime  @default(now())
  userId      String    @db.ObjectId
  communityId String    @db.ObjectId

  @@unique([userId, communityId])
}

model Community {
  id          String       @id @default(auto()) @map("_id") @db.ObjectId
  name        String
  memberships Membership[] @relation("CommunityMemberships")
  channels    Channel[]
  createdAt   DateTime     @default(now())
  avatar      String?
  banner      String?
  description String?
  UserRoles   UserRoles[]

  @@unique([name])
}

model Channel {
  id                String              @id @default(auto()) @map("_id") @db.ObjectId
  name              String
  communityId       String              @db.ObjectId
  community         Community?          @relation(fields: [communityId], references: [id], onDelete: Cascade)
  createdAt         DateTime            @default(now())
  type              ChannelType         @default(TEXT)
  Message           Message[]
  ChannelMembership ChannelMembership[] @relation("ChannelMembership")
  isPrivate         Boolean             @default(false)

  @@unique([communityId, name])
}

model ChannelMembership {
  id        String   @id @default(auto()) @map("_id") @db.ObjectId
  user      User     @relation("UserChannelMemberships", fields: [userId], references: [id], onDelete: Cascade)
  channel   Channel  @relation("ChannelMembership", fields: [channelId], references: [id], onDelete: Cascade)
  joinedAt  DateTime @default(now())
  userId    String   @db.ObjectId
  channelId String   @db.ObjectId
  addedBy   String?  @db.ObjectId // Who added this user (for private channels)

  @@unique([userId, channelId])
}

model AliasGroup {
  id          String             @id @default(auto()) @map("_id") @db.ObjectId
  name        String
  communityId String             @db.ObjectId
  members     AliasGroupMember[] @relation(fields: [], references: [])
  createdAt   DateTime           @default(now())

  @@unique([communityId, name])
}

model AliasGroupMember {
  id           String      @id @default(auto()) @map("_id") @db.ObjectId
  aliasGroupId String      @db.ObjectId
  userId       String      @db.ObjectId
  aliasGroup   AliasGroup? @relation(fields: [aliasGroupId], references: [id])
}

model Role {
  id        String        @id @default(auto()) @map("_id") @db.ObjectId
  name      String
  actions   RbacActions[] @default([])
  createdAt DateTime      @default(now())

  UserRoles UserRoles[]

  @@unique([name])
}

model UserRoles {
  id             String     @id @default(auto()) @map("_id") @db.ObjectId
  // This is the same relationship as Membership, but it simplifies the auth lookup since our token only has the userId
  userId         String     @db.ObjectId
  communityId    String?    @db.ObjectId
  roleId         String     @db.ObjectId
  isInstanceRole Boolean    @default(false)
  user           User       @relation(fields: [userId], references: [id], onDelete: Cascade)
  community      Community? @relation(fields: [communityId], references: [id], onDelete: Cascade)
  role           Role       @relation(fields: [roleId], references: [id], onDelete: Cascade)

  @@unique([userId, communityId, roleId])
}

model DirectMessageGroup {
  id        String                     @id @default(auto()) @map("_id") @db.ObjectId
  name      String? // Optional, for group DMs
  members   DirectMessageGroupMember[]
  createdAt DateTime                   @default(now())
  messages  Message[]                  @relation("DirectMessageGroupMessages")
  isGroup   Boolean                    @default(false) // true for group DMs, false for 1:1
}

model DirectMessageGroupMember {
  id       String             @id @default(auto()) @map("_id") @db.ObjectId
  groupId  String             @db.ObjectId
  userId   String             @db.ObjectId
  group    DirectMessageGroup @relation(fields: [groupId], references: [id], onDelete: Cascade)
  user     User               @relation(fields: [userId], references: [id], onDelete: Cascade)
  joinedAt DateTime           @default(now())

  @@unique([groupId, userId])
}

model Friendship {
  id        String           @id @default(auto()) @map("_id") @db.ObjectId
  userAId   String           @db.ObjectId
  userBId   String           @db.ObjectId
  createdAt DateTime         @default(now())
  status    FriendshipStatus @default(PENDING)
  userA     User             @relation("FriendshipA", fields: [userAId], references: [id], onDelete: Cascade)
  userB     User             @relation("FriendshipB", fields: [userBId], references: [id], onDelete: Cascade)

  @@unique([userAId, userBId])
}

model File {
  id           String    @id @default(auto()) @map("_id") @db.ObjectId
  filename     String // Original filename
  mimeType     String // MIME type (image/jpeg, etc.)
  fileType     FileType // Enum for different file types
  size         Int // File size in bytes
  checksum     String // SHA-256 hash for integrity
  uploadedBy   User?     @relation(fields: [uploadedById], references: [id])
  uploadedById String?   @db.ObjectId
  uploadedAt   DateTime  @default(now())
  deletedAt    DateTime? // Soft delete
  resourceType ResourceType
  resourceId   String? // ID of the resource this file is associated with (userId, communityId, messageId, etc.)

  // Storage configuration
  storageType StorageType @default(LOCAL)
  storagePath String // Local path or cloud key

  @@index([uploadedById]) // show my files or files for specific user
  @@index([deletedAt]) // For cleaning up deleted files
  @@index([resourceType, resourceId]) // For fetching files related to a specific resource
}

enum FileType {
  IMAGE
  VIDEO
  AUDIO
  DOCUMENT
  OTHER
}

enum ResourceType {
  USER_AVATAR
  USER_BANNER
  COMMUNITY_BANNER
  COMMUNITY_AVATAR
  MESSAGE_ATTACHMENT
  CUSTOM_EMOJI
}

enum StorageType {
  LOCAL
  S3
  AZURE_BLOB
}

enum FriendshipStatus {
  PENDING
  ACCEPTED
  BLOCKED
}

enum ChannelType {
  TEXT
  VOICE
}

enum RbacActions {
  // These are just a bunch I randomly thought of but we'll modify this as we go
  DELETE_MESSAGE
  DELETE_CHANNEL
  DELETE_COMMUNITY
  DELETE_INVITE
  DELETE_USER
  DELETE_ROLE
  DELETE_ALIAS_GROUP
  DELETE_ALIAS_GROUP_MEMBER
  DELETE_INSTANCE_INVITE
  DELETE_MEMBER
  DELETE_REACTION
  CREATE_MESSAGE
  CREATE_CHANNEL
  CREATE_COMMUNITY
  CREATE_INVITE
  CREATE_USER
  CREATE_ROLE
  CREATE_ALIAS_GROUP
  CREATE_ALIAS_GROUP_MEMBER
  CREATE_INSTANCE_INVITE
  CREATE_MEMBER
  CREATE_REACTION
  JOIN_CHANNEL
  READ_MESSAGE
  READ_CHANNEL
  READ_COMMUNITY
  READ_ALL_COMMUNITIES // TODO: we need to rethink this
  READ_USER
  READ_ROLE
  READ_ALIAS_GROUP
  READ_ALIAS_GROUP_MEMBER
  READ_INSTANCE_INVITE
  READ_MEMBER
  UPDATE_COMMUNITY
  UPDATE_CHANNEL
  UPDATE_MESSAGE
  UPDATE_USER
  UPDATE_ROLE
  UPDATE_ALIAS_GROUP
  UPDATE_ALIAS_GROUP_MEMBER
  UPDATE_INSTANCE_INVITE
  UPDATE_MEMBER
}

enum InstanceRole {
  OWNER
  USER
}

type Span {
  type        SpanType
  text        String?
  userId      String? // For USER_MENTION
  specialKind String? // For SPECIAL_MENTION: "here", "channel"
  communityId String? // For COMMUNITY_MENTION
  aliasId     String? // For ALIAS_MENTION
}

// New enum with more mention types
enum SpanType {
  PLAINTEXT
  USER_MENTION
  SPECIAL_MENTION
  COMMUNITY_MENTION
  ALIAS_MENTION
}

type Reaction {
  emoji   String
  userIds String[]
}
