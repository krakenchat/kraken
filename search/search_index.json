{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Kraken","text":"<p>Self-hosted Discord-like voice and text chat.</p> <p>Kraken is an open-source communication platform that gives you full control over your data. Built with a modern stack \u2014 NestJS, React, MongoDB, and LiveKit \u2014 it provides real-time messaging, voice and video calls, and community management out of the box.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>Real-time messaging \u2014 WebSocket-powered text channels with mentions, reactions, attachments, and threads</li> <li>Voice &amp; video calls \u2014 Powered by LiveKit with screen sharing and replay buffer support</li> <li>Communities \u2014 Create servers with text and voice channels, roles, and permissions</li> <li>Direct messages \u2014 Private conversations and group DMs with file attachments</li> <li>Role-based access control \u2014 Granular permissions at the instance and community level</li> <li>Desktop app \u2014 Electron-based desktop client alongside the web interface</li> <li>Self-hosted \u2014 Run on your own infrastructure with Docker Compose or Kubernetes</li> </ul>"},{"location":"#quick-links","title":"Quick links","text":"<ul> <li> <p> Installation</p> <p>Get Kraken running with Docker Compose \u2014 from first launch to production.</p> </li> <li> <p> Configuration</p> <p>Environment variables reference for backend and frontend.</p> </li> <li> <p> Kubernetes</p> <p>Deploy Kraken to a Kubernetes cluster with the official Helm chart.</p> </li> <li> <p> Desktop App</p> <p>Download the Electron desktop client for Windows and Linux.</p> </li> <li> <p> Contributing</p> <p>Help improve Kraken \u2014 bug reports, features, and code contributions.</p> </li> </ul>"},{"location":"#tech-stack","title":"Tech stack","text":"Layer Technology Backend NestJS (TypeScript) Frontend React 19 + Vite + Material UI Database MongoDB with Prisma ORM Real-time Socket.IO with Redis adapter Voice/Video LiveKit State TanStack Query v5 Auth JWT with Passport.js Desktop Electron"},{"location":"#license","title":"License","text":"<p>Kraken is dual-licensed under the AGPLv3 and a commercial license. Free for everyone \u2014 including commercial use \u2014 as long as you comply with AGPL terms. A commercial license is available for proprietary deployments.</p> <p>Contact: licensing {at} krakenchat [dot] app</p>"},{"location":"license/","title":"License","text":"<p>Kraken is dual-licensed under the AGPLv3 and a commercial license.</p>"},{"location":"license/#agplv3-default","title":"AGPLv3 (default)","text":"<p>The GNU Affero General Public License v3 is the default license. It's free for everyone \u2014 including commercial use \u2014 as long as you comply with its terms. The primary requirement: if you modify and deploy Kraken, you must share your source code.</p>"},{"location":"license/#commercial-license","title":"Commercial license","text":"<p>A commercial license is available for those who want to keep modifications proprietary or avoid AGPL source-sharing obligations. Contact licensing {at} krakenchat [dot] app for details.</p>"},{"location":"license/#frequently-asked-questions","title":"Frequently asked questions","text":"<p>Can I use Kraken for free? :   Yes. Anyone may use Kraken under the AGPLv3, including for commercial purposes, as long as you comply with the AGPL terms (share your source code if you modify and deploy it).</p> <p>I'm a student, educator, or non-profit. Do I need a commercial license? :   No. Use under AGPLv3 is free for everyone, including academic and non-profit organizations.</p> <p>I want to self-host Kraken for myself, my friends, or my community. Do I need a commercial license? :   No. Personal, hobby, and self-hosted instances \u2014 including those you run for free for your own community \u2014 do not require a commercial license. Just follow the AGPLv3 terms.</p> <p>I want to host Kraken as a free public service. Do I need a commercial license? :   No. Hosting Kraken as a free, open, non-profit community service is allowed under the AGPLv3.</p> <p>I want to modify or contribute to Kraken. Do I need a commercial license? :   Contributions and modifications are welcome under the AGPLv3. As long as you release your modified source code per the AGPL terms, no commercial license is needed.</p> <p>I want to run Kraken in my startup or SaaS offering. Do I need a commercial license? :   Not necessarily. Businesses can use Kraken under the AGPLv3 \u2014 but AGPL requires that you make the complete source code of your deployment (including modifications) available to your users. If you don't want that obligation, you need a commercial license.</p> <p>I want to offer Kraken as a paid hosted service. What are my obligations? :   You have two options: (1) comply with the AGPLv3 by making your full service source code available, or (2) purchase a commercial license to keep your source proprietary.</p> <p>I want to integrate Kraken into a closed-source or proprietary product. :   The AGPLv3 does not allow this \u2014 you would need to open-source the combined work. If you want to keep your product closed-source, you must purchase a commercial license.</p> <p>I'm still unsure. :   Email licensing {at} krakenchat [dot] app for clarification.</p> <p>See also: LICENSE | LICENSE_COM</p>"},{"location":"security/","title":"Security","text":""},{"location":"security/#reporting-vulnerabilities","title":"Reporting vulnerabilities","text":"<p>Report security issues via GitHub private vulnerability reporting. Include a description, steps to reproduce, and potential impact. Only maintainers can see the report until a fix is released.</p>"},{"location":"security/#self-hosting-checklist","title":"Self-hosting checklist","text":"<ul> <li> Change all default JWT secrets \u2014 generate with <code>openssl rand -base64 32</code></li> <li> Use HTTPS with valid TLS certificates</li> <li> Restrict network access to MongoDB and Redis (don't expose ports publicly)</li> <li> Enable authentication on all database connections</li> <li> Keep images updated \u2014 watch for Dependabot alerts</li> <li> Back up MongoDB regularly</li> </ul>"},{"location":"architecture/backend/","title":"Backend Architecture","text":"<p>The backend is a NestJS application in <code>backend/src/</code> using modular architecture with Prisma ORM, Socket.IO, and LiveKit integration.</p>"},{"location":"architecture/backend/#module-organization","title":"Module Organization","text":""},{"location":"architecture/backend/#core-infrastructure","title":"Core Infrastructure","text":"Module Purpose <code>auth/</code> JWT authentication, Passport strategies, RBAC guards <code>database/</code> Prisma service and connection management <code>redis/</code> Redis connection, pub/sub <code>cache/</code> Redis caching service <code>roles/</code> Role definitions and permission checking <code>health/</code> Health check endpoints"},{"location":"architecture/backend/#user-social","title":"User &amp; Social","text":"Module Purpose <code>user/</code> User CRUD, profiles, avatars, banners <code>friends/</code> Friend requests, accept/decline/block <code>presence/</code> Online status tracking (multi-connection aware) <code>appearance-settings/</code> Theme preferences (accent color, intensity)"},{"location":"architecture/backend/#community-channels","title":"Community &amp; Channels","text":"Module Purpose <code>community/</code> Community CRUD, settings, invites <code>channels/</code> Text/voice channel management, reordering <code>membership/</code> Community membership (join/leave) <code>channel-membership/</code> Private channel access control <code>invite/</code> Instance and community invitation system <code>onboarding/</code> First-time instance setup wizard <code>alias-groups/</code> Mention groups within communities"},{"location":"architecture/backend/#messaging","title":"Messaging","text":"Module Purpose <code>messages/</code> Message CRUD with spans, attachments, reactions <code>threads/</code> Thread replies, subscription, notifications <code>direct-messages/</code> 1:1 and group DM management <code>notifications/</code> Notification creation and delivery <code>read-receipts/</code> Message read tracking"},{"location":"architecture/backend/#voice-media","title":"Voice &amp; Media","text":"Module Purpose <code>livekit/</code> Token generation, room management, replay buffer <code>rooms/</code> Room state for voice/video sessions <code>file/</code> Authenticated file serving with range support <code>file-upload/</code> File upload handling <code>storage/</code> Storage abstraction layer <code>storage-quota/</code> Per-user storage quota enforcement"},{"location":"architecture/backend/#moderation","title":"Moderation","text":"Module Purpose <code>moderation/</code> Ban, kick, timeout, moderation logs <code>instance/</code> Instance-level settings and admin panel"},{"location":"architecture/backend/#request-flow","title":"Request Flow","text":"<pre><code>HTTP Request\n    |\nController (route + decorators)\n    |-- @RequiredActions(RbacActions.CREATE_MESSAGE)\n    |-- @RbacResource({ type: CHANNEL, idKey: 'channelId', source: PAYLOAD })\n    |\nGuards (JwtAuthGuard -&gt; RbacGuard)\n    |\nService (business logic)\n    |\nPrisma (database operations)\n    |\nEventEmitter2 (domain events) --&gt; RoomSubscriptionHandler --&gt; WebsocketService\n</code></pre>"},{"location":"architecture/backend/#authentication-flow","title":"Authentication Flow","text":"<ol> <li>Login: <code>POST /auth/login</code> -&gt; validates credentials -&gt; returns JWT access + refresh tokens</li> <li>Access: Every request includes <code>Authorization: Bearer &lt;token&gt;</code> -&gt; <code>JwtAuthGuard</code> validates</li> <li>Refresh: <code>POST /auth/refresh</code> -&gt; validates refresh token -&gt; issues new pair</li> <li>RBAC: <code>RbacGuard</code> checks user's roles against <code>@RequiredActions()</code> decorator</li> </ol>"},{"location":"architecture/backend/#rbac-pattern","title":"RBAC Pattern","text":"<pre><code>@RequiredActions(RbacActions.CREATE_MESSAGE)\n@RbacResource({\n  type: RbacResourceType.CHANNEL,\n  idKey: 'channelId',\n  source: ResourceIdSource.PAYLOAD,\n})\n@Post()\nasync createMessage(@Body() dto: CreateMessageDto) { ... }\n</code></pre> <p>The guard resolves the resource (channel -&gt; community), loads the user's roles for that community, and checks if any role includes the required action.</p>"},{"location":"architecture/backend/#websocket-architecture","title":"WebSocket Architecture","text":""},{"location":"architecture/backend/#gateways","title":"Gateways","text":"<ul> <li>MessagesGateway -- <code>SEND_MESSAGE</code>, <code>EDIT_MESSAGE</code>, <code>DELETE_MESSAGE</code>, reactions, typing</li> <li>PresenceGateway -- User connect/disconnect, online status</li> </ul> <p>Both gateways use <code>JwtWsGuard</code> for authentication.</p>"},{"location":"architecture/backend/#websocketservice","title":"WebsocketService","text":"<p>Central service for broadcasting events to rooms:</p> <pre><code>this.websocketService.sendToRoom(\n  RoomName.community(communityId),\n  ServerEvents.CHANNEL_CREATED,\n  payload,\n);\n</code></pre>"},{"location":"architecture/backend/#redis-adapter","title":"Redis Adapter","text":"<p>In multi-pod deployments, <code>RedisIoAdapter</code> ensures Socket.IO events reach all connected clients regardless of which pod they're connected to.</p>"},{"location":"architecture/backend/#event-emission","title":"Event Emission","text":"<p>Two patterns coexist:</p> <ol> <li>EventEmitter2 -- Services emit domain events; <code>RoomSubscriptionHandler</code> translates to WebSocket broadcasts. Used when the service doesn't have <code>WebsocketService</code> injected.</li> <li>Direct -- Gateways and hybrid services call <code>websocketService.sendToRoom()</code> directly.</li> </ol> <p>See WebSocket Patterns for the full guide.</p>"},{"location":"architecture/backend/#key-patterns","title":"Key Patterns","text":""},{"location":"architecture/backend/#sensitive-user-fields","title":"Sensitive User Fields","text":"<p>Never return raw Prisma <code>User</code> objects. Always wrap in <code>new UserEntity(user)</code> which applies <code>@Exclude()</code> decorators. Use <code>PUBLIC_USER_SELECT</code> constant for database queries to avoid fetching sensitive fields.</p>"},{"location":"architecture/backend/#openapiswagger","title":"OpenAPI/Swagger","text":"<ul> <li>Add <code>@ApiProperty({ enum: XxxValues })</code> for Prisma enums (NestJS Swagger plugin can't introspect them)</li> <li>Import <code>PartialType</code> from <code>@nestjs/swagger</code>, not <code>@nestjs/mapped-types</code></li> <li>Add <code>@ApiOkResponse({ type: FooDto })</code> to controllers for typed responses</li> </ul>"},{"location":"architecture/backend/#file-serving","title":"File Serving","text":"<p>Files are served through authenticated endpoints with range request support for video streaming. The <code>FileService</code> validates access permissions before serving.</p>"},{"location":"architecture/database/","title":"Database Schema","text":"<p>Kraken uses MongoDB with Prisma ORM. Schema changes use <code>prisma db push</code> (no migrations). MongoDB runs as a replica set for change stream support.</p>"},{"location":"architecture/database/#core-models","title":"Core Models","text":""},{"location":"architecture/database/#user","title":"User","text":"<pre><code>model User {\n  id             String       @id @default(auto()) @map(\"_id\") @db.ObjectId\n  username       String       @unique\n  email          String?      @unique\n  verified       Boolean      @default(false)\n  hashedPassword String\n  role           InstanceRole @default(USER)\n  displayName    String?\n  avatarUrl      String?\n  lastSeen       DateTime?\n  createdAt      DateTime     @default(now())\n\n  memberships                       Membership[]\n  UserRoles                         UserRoles[]\n  RefreshToken                      RefreshToken[]\n  ChannelMembership                 ChannelMembership[]\n  directMessageGroupMemberships     DirectMessageGroupMember[]\n  friendshipsA                      Friendship[] @relation(\"FriendshipA\")\n  friendshipsB                      Friendship[] @relation(\"FriendshipB\")\n}\n</code></pre>"},{"location":"architecture/database/#community","title":"Community","text":"<pre><code>model Community {\n  id          String       @id @default(auto()) @map(\"_id\") @db.ObjectId\n  name        String       @unique\n  description String?\n  avatar      String?\n  banner      String?\n  createdAt   DateTime     @default(now())\n\n  memberships Membership[]\n  channels    Channel[]\n  UserRoles   UserRoles[]\n}\n</code></pre>"},{"location":"architecture/database/#channel","title":"Channel","text":"<pre><code>model Channel {\n  id          String      @id @default(auto()) @map(\"_id\") @db.ObjectId\n  name        String\n  communityId String      @db.ObjectId\n  type        ChannelType @default(TEXT)\n  isPrivate   Boolean     @default(false)\n  createdAt   DateTime    @default(now())\n\n  community         Community?          @relation(fields: [communityId], references: [id], onDelete: Cascade)\n  Message           Message[]\n  ChannelMembership ChannelMembership[]\n\n  @@unique([communityId, name])\n}\n\nenum ChannelType {\n  TEXT\n  VOICE\n}\n</code></pre>"},{"location":"architecture/database/#message","title":"Message","text":"<p>Messages use a span-based rich text system and support both channel and DM contexts.</p> <pre><code>model Message {\n  id                   String       @id @default(auto()) @map(\"_id\") @db.ObjectId\n  channelId            String?      @db.ObjectId\n  directMessageGroupId String?      @db.ObjectId\n  authorId             String\n  spans                Span[]\n  attachments          Attachment[]\n  reactions            Reaction[]\n  sentAt               DateTime     @default(now())\n  editedAt             DateTime?\n  deletedAt            DateTime?\n\n  channel            Channel?            @relation(fields: [channelId], references: [id], onDelete: Cascade)\n  directMessageGroup DirectMessageGroup? @relation(fields: [directMessageGroupId], references: [id], onDelete: Cascade)\n}\n</code></pre>"},{"location":"architecture/database/#span-system-rich-text","title":"Span System (Rich Text)","text":"<pre><code>type Span {\n  type        SpanType\n  text        String?\n  userId      String?     // USER_MENTION\n  specialKind String?     // SPECIAL_MENTION: \"here\", \"everyone\", \"mods\"\n  channelId   String?     // CHANNEL_MENTION\n  communityId String?     // COMMUNITY_MENTION\n  aliasId     String?     // ALIAS_MENTION\n}\n\nenum SpanType {\n  PLAINTEXT\n  USER_MENTION\n  SPECIAL_MENTION\n  CHANNEL_MENTION\n  COMMUNITY_MENTION\n  ALIAS_MENTION\n}\n</code></pre>"},{"location":"architecture/database/#embedded-types","title":"Embedded Types","text":"<pre><code>type Attachment {\n  url      String\n  filename String\n  filetype String\n  size     Int\n}\n\ntype Reaction {\n  emoji   String\n  userIds String[]\n}\n</code></pre>"},{"location":"architecture/database/#membership-access-control","title":"Membership &amp; Access Control","text":""},{"location":"architecture/database/#membership-community","title":"Membership (Community)","text":"<pre><code>model Membership {\n  id          String   @id @default(auto()) @map(\"_id\") @db.ObjectId\n  userId      String   @db.ObjectId\n  communityId String   @db.ObjectId\n  joinedAt    DateTime @default(now())\n\n  user      User      @relation(fields: [userId], references: [id])\n  community Community @relation(fields: [communityId], references: [id])\n\n  @@unique([userId, communityId])\n}\n</code></pre>"},{"location":"architecture/database/#channelmembership-private-channels","title":"ChannelMembership (Private Channels)","text":"<pre><code>model ChannelMembership {\n  id        String   @id @default(auto()) @map(\"_id\") @db.ObjectId\n  userId    String   @db.ObjectId\n  channelId String   @db.ObjectId\n  joinedAt  DateTime @default(now())\n  addedBy   String?  @db.ObjectId\n\n  user    User    @relation(fields: [userId], references: [id], onDelete: Cascade)\n  channel Channel @relation(fields: [channelId], references: [id], onDelete: Cascade)\n\n  @@unique([userId, channelId])\n}\n</code></pre>"},{"location":"architecture/database/#rbac-system","title":"RBAC System","text":"<pre><code>model Role {\n  id        String        @id @default(auto()) @map(\"_id\") @db.ObjectId\n  name      String        @unique\n  actions   RbacActions[] @default([])\n  createdAt DateTime      @default(now())\n\n  UserRoles UserRoles[]\n}\n\nmodel UserRoles {\n  id             String     @id @default(auto()) @map(\"_id\") @db.ObjectId\n  userId         String     @db.ObjectId\n  communityId    String?    @db.ObjectId  // Null for instance-level roles\n  roleId         String     @db.ObjectId\n  isInstanceRole Boolean    @default(false)\n\n  user      User       @relation(fields: [userId], references: [id], onDelete: Cascade)\n  community Community? @relation(fields: [communityId], references: [id], onDelete: Cascade)\n  role      Role       @relation(fields: [roleId], references: [id], onDelete: Cascade)\n\n  @@unique([userId, communityId, roleId])\n}\n</code></pre>"},{"location":"architecture/database/#direct-messaging","title":"Direct Messaging","text":"<pre><code>model DirectMessageGroup {\n  id        String                     @id @default(auto()) @map(\"_id\") @db.ObjectId\n  name      String?                    // Optional, for group DMs\n  isGroup   Boolean                    @default(false)\n  createdAt DateTime                   @default(now())\n\n  members  DirectMessageGroupMember[]\n  messages Message[]                   @relation(\"DirectMessageGroupMessages\")\n}\n\nmodel DirectMessageGroupMember {\n  id       String             @id @default(auto()) @map(\"_id\") @db.ObjectId\n  groupId  String             @db.ObjectId\n  userId   String             @db.ObjectId\n  joinedAt DateTime           @default(now())\n\n  group DirectMessageGroup @relation(fields: [groupId], references: [id], onDelete: Cascade)\n  user  User               @relation(fields: [userId], references: [id], onDelete: Cascade)\n\n  @@unique([groupId, userId])\n}\n</code></pre>"},{"location":"architecture/database/#social-features","title":"Social Features","text":""},{"location":"architecture/database/#friendship","title":"Friendship","text":"<pre><code>model Friendship {\n  id        String           @id @default(auto()) @map(\"_id\") @db.ObjectId\n  userAId   String           @db.ObjectId\n  userBId   String           @db.ObjectId\n  status    FriendshipStatus @default(PENDING)\n  createdAt DateTime         @default(now())\n\n  userA User @relation(\"FriendshipA\", fields: [userAId], references: [id], onDelete: Cascade)\n  userB User @relation(\"FriendshipB\", fields: [userBId], references: [id], onDelete: Cascade)\n\n  @@unique([userAId, userBId])\n}\n\nenum FriendshipStatus {\n  PENDING\n  ACCEPTED\n  BLOCKED\n}\n</code></pre>"},{"location":"architecture/database/#alias-groups-mention-groups","title":"Alias Groups (Mention Groups)","text":"<pre><code>model AliasGroup {\n  id          String             @id @default(auto()) @map(\"_id\") @db.ObjectId\n  name        String\n  communityId String             @db.ObjectId\n  members     AliasGroupMember[]\n  createdAt   DateTime           @default(now())\n\n  @@unique([communityId, name])\n}\n</code></pre>"},{"location":"architecture/database/#relationships-diagram","title":"Relationships Diagram","text":"<pre><code>User \u2500\u2500\u2500\u2500\u2500\u2500\u2510\n    \u2502      \u251c\u2500\u2500 Membership \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 Community\n    \u2502      \u251c\u2500\u2500 UserRoles \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 Role\n    \u2502      \u251c\u2500\u2500 ChannelMembership \u2500\u2500\u2500 Channel \u2500\u2500 Community\n    \u2502      \u251c\u2500\u2500 DM Group Member \u2500\u2500\u2500\u2500\u2500 DirectMessageGroup \u2500\u2500 Message\n    \u2502      \u2514\u2500\u2500 Friendship (bidirectional)\n    \u2502\n    \u2514\u2500\u2500 Message \u2500\u2500 Channel \u2500\u2500 Community\n</code></pre>"},{"location":"architecture/database/#query-patterns","title":"Query Patterns","text":""},{"location":"architecture/database/#get-users-communities","title":"Get User's Communities","text":"<pre><code>const userCommunities = await prisma.membership.findMany({\n  where: { userId },\n  include: { community: { include: { channels: true } } },\n});\n</code></pre>"},{"location":"architecture/database/#paginated-messages","title":"Paginated Messages","text":"<pre><code>const messages = await prisma.message.findMany({\n  where: { channelId, deletedAt: null },\n  orderBy: { sentAt: 'desc' },\n  take: 50,\n  skip: offset,\n});\n</code></pre>"},{"location":"architecture/database/#check-user-permissions","title":"Check User Permissions","text":"<pre><code>const userRoles = await prisma.userRoles.findMany({\n  where: {\n    userId,\n    OR: [\n      { communityId: null, isInstanceRole: true },\n      { communityId },\n    ],\n  },\n  include: { role: true },\n});\n</code></pre>"},{"location":"architecture/database/#schema-management","title":"Schema Management","text":"<ul> <li>Development: <code>prisma db push</code> applies changes directly</li> <li>Production: Coordinate schema changes carefully; back up before major changes</li> <li>Indexing: Prisma auto-creates indexes for <code>@unique</code> and <code>@@unique</code> constraints; compound indexes on <code>Message.channelId + sentAt</code> and <code>Membership.userId + communityId</code> are critical for performance</li> </ul>"},{"location":"architecture/frontend/","title":"Frontend Architecture","text":"<p>The frontend is a React 19 + TypeScript + Vite application in <code>frontend/src/</code> using Material UI for components and TanStack Query v5 for server state.</p>"},{"location":"architecture/frontend/#state-management","title":"State Management","text":""},{"location":"architecture/frontend/#tanstack-query-v5","title":"TanStack Query v5","text":"<p>All server state is managed through TanStack Query. There is no Redux store or other client-side state manager.</p> <pre><code>// Fetching data\nconst { data: channels } = useQuery({\n  queryKey: channelsControllerFindAllForCommunityQueryKey({ path: { communityId } }),\n  queryFn: () =&gt; channelsControllerFindAllForCommunity({ path: { communityId } }),\n});\n\n// Mutations\nconst { mutate } = useMutation({\n  mutationFn: (dto) =&gt; messagesControllerCreate({ body: dto }),\n  onSuccess: () =&gt; queryClient.invalidateQueries({ queryKey: ['messages'] }),\n});\n</code></pre>"},{"location":"architecture/frontend/#generated-api-client","title":"Generated API Client","text":"<p>The frontend uses a generated TypeScript client from the backend's OpenAPI spec, located in <code>api-client/</code>. Functions are fully typed and follow the pattern <code>controllerNameMethodName()</code>.</p> <pre><code>import { messagesControllerCreate } from '../api-client';\n</code></pre> <p>Never use raw <code>fetch</code> or <code>client.post()</code> -- always use generated SDK functions.</p>"},{"location":"architecture/frontend/#real-time-cache-sync","title":"Real-Time Cache Sync","text":"<p>WebSocket events keep the TanStack Query cache in sync:</p> <ul> <li>Direct updates: High-frequency events (messages, reactions, presence) write directly to the cache via <code>queryClient.setQueryData()</code></li> <li>Invalidation: Low-frequency events (channels, roles, settings) mark the cache stale via <code>queryClient.invalidateQueries()</code></li> <li>Ephemeral: Transient events (typing indicators) use local component state via <code>useServerEvent()</code></li> </ul> <p>See WebSocket Patterns for the full decision framework.</p>"},{"location":"architecture/frontend/#socket-hub","title":"Socket Hub","text":"<p>The <code>socket-hub/</code> directory manages all WebSocket communication:</p> <pre><code>socket-hub/\n  SocketHubProvider.tsx   -- Context provider, connects on mount\n  useServerEvent.ts       -- Hook for ephemeral events in components\n  useSocketHub.ts         -- Access the socket hub context\n  emitter.ts              -- Client-side event emitter\n  handlers/\n    index.ts              -- Handler registry (maps events to handlers)\n    messageHandlers.ts    -- NEW_MESSAGE, UPDATE_MESSAGE, DELETE_MESSAGE, reactions\n    threadHandlers.ts     -- Thread reply events\n    communityHandlers.ts  -- Channel/community CRUD events\n    roleHandlers.ts       -- Role CRUD and assignment events\n    presenceHandlers.ts   -- Online/offline, profile updates\n    voiceHandlers.ts      -- Voice presence join/leave/update\n    moderationHandlers.ts -- Ban, kick, timeout events\n    notificationHandlers.ts -- Notification events\n    reconnectHandlers.ts  -- Reconnection state sync\n</code></pre> <p>The <code>SocketHubProvider</code> connects to Socket.IO on mount, registers all handlers from the registry, and passes the <code>queryClient</code> to each handler for cache manipulation.</p>"},{"location":"architecture/frontend/#component-organization","title":"Component Organization","text":"<p>Components are organized by feature under <code>components/</code>:</p> Directory Purpose <code>Channel/</code> Channel views, message list, composer <code>Community/</code> Community sidebar, settings, member list <code>CommunityList/</code> Left sidebar community icons <code>Common/</code> Shared components (UserAvatar, modals, etc.) <code>DirectMessage/</code> DM conversation view <code>DirectMessages/</code> DM list and group management <code>Friends/</code> Friend list, requests <code>Message/</code> Message rendering, reactions, attachments <code>Mobile/</code> Mobile-specific layout and navigation <code>Moderation/</code> Ban, kick, timeout dialogs and panels <code>NavBar/</code> Top navigation bar <code>Notifications/</code> Notification center and badges <code>Onboarding/</code> Instance setup wizard <code>Profile/</code> User profile cards and settings <code>Settings/</code> User settings pages <code>Thread/</code> Thread panel and reply list <code>Voice/</code> Voice/video UI, controls, participant tiles <code>admin/</code> Instance admin panel <code>Electron/</code> Desktop app specific components <code>PWA/</code> Progressive Web App install prompts"},{"location":"architecture/frontend/#contexts","title":"Contexts","text":"<p>React contexts provide cross-cutting state:</p> Context Purpose <code>VoiceContext</code> Active voice connection state, join/leave/mute <code>AvatarCacheContext</code> Authenticated avatar URL caching <code>ThreadPanelContext</code> Thread panel open/close state <code>ReplayBufferContext</code> Replay buffer session state <code>RoomContext</code> LiveKit room instance <code>VideoOverlayContext</code> Video overlay visibility <code>ThemeContext</code> Theme preferences (accent color, intensity) <code>NotificationContext</code> Notification state and display <code>UserProfileContext</code> Profile card popover state"},{"location":"architecture/frontend/#custom-hooks","title":"Custom Hooks","text":"<p>~47 hooks in <code>hooks/</code> encapsulate reusable logic:</p> <p>Messaging: <code>useMessages</code>, <code>useSendMessage</code>, <code>useMentionAutocomplete</code>, <code>useMessagePermissions</code>, <code>useMessageVisibility</code>, <code>useMessageFileUpload</code></p> <p>Voice: <code>useVoiceConnection</code>, <code>useRoom</code>, <code>useScreenShare</code>, <code>useLocalMediaState</code>, <code>useDeviceSettings</code>, <code>useDeviceTest</code>, <code>usePushToTalk</code>, <code>useSpeakingDetection</code>, <code>useVoiceParticipantCount</code>, <code>useVoicePresenceHeartbeat</code>, <code>useVoiceRecovery</code>, <code>useVoiceSettings</code>, <code>useParticipantTracks</code>, <code>useDeafenEffect</code></p> <p>Real-time: <code>useSocket</code>, <code>useTypingUsers</code>, <code>useTypingEmitter</code>, <code>useNotifications</code>, <code>useNotificationSideEffects</code>, <code>useAutoMarkNotificationsRead</code>, <code>useReadReceipts</code></p> <p>Threads: <code>useThreadReplies</code>, <code>useThreadSubscription</code></p> <p>Media: <code>useAuthenticatedFile</code>, <code>useAuthenticatedImage</code>, <code>useFileUpload</code>, <code>useReplayBuffer</code></p> <p>UI: <code>useResponsive</code>, <code>useSwipeGesture</code>, <code>useHapticFeedback</code>, <code>useDebounce</code>, <code>useThemeSync</code>, <code>usePWA</code>, <code>usePWAInstall</code></p> <p>Profile: <code>useCurrentUser</code>, <code>useProfileForm</code>, <code>useCommunityForm</code></p>"},{"location":"architecture/frontend/#platform-separation-web-vs-electron","title":"Platform Separation (Web vs Electron)","text":"<p>Use the centralized platform utility for detection:</p> <pre><code>import { isElectron, isWeb, hasElectronFeature } from './utils/platform';\n</code></pre> <p>Platform differences are encapsulated in hooks (e.g., <code>useScreenShare()</code> handles Electron source picker vs browser native). Keep platform checks out of components.</p>"},{"location":"architecture/overview/","title":"Architecture Overview","text":"<p>Kraken is a self-hosted Discord-like communication platform with real-time messaging, voice/video calls, and community management.</p>"},{"location":"architecture/overview/#system-architecture","title":"System Architecture","text":"<pre><code>graph LR\n    Browser[\"Browser / Electron\"]\n    Frontend[\"Frontend&lt;br/&gt;(React + Vite)\"]\n    Backend[\"Backend&lt;br/&gt;(NestJS)\"]\n    MongoDB[(MongoDB)]\n    Redis[(Redis)]\n    LiveKit[\"LiveKit Server\"]\n\n    Browser --&gt;|HTTP/WS| Frontend\n    Browser --&gt;|REST + Socket.IO| Backend\n    Browser --&gt;|WebRTC| LiveKit\n    Backend --&gt; MongoDB\n    Backend --&gt; Redis\n    Backend --&gt; LiveKit\n    Frontend -.-&gt;|Static assets| Browser</code></pre>"},{"location":"architecture/overview/#communication-patterns","title":"Communication Patterns","text":"Protocol Technology Purpose REST OpenAPI-generated client CRUD operations, auth, file uploads WebSocket Socket.IO + Redis adapter Real-time events (messages, presence, notifications) WebRTC LiveKit Voice, video, screen sharing"},{"location":"architecture/overview/#rest-api","title":"REST API","text":"<p>The backend exposes an OpenAPI spec. The frontend uses a generated TypeScript client (<code>frontend/src/api-client/</code>) -- never raw <code>fetch</code> or <code>axios</code>. When backend controllers change, regenerate the client:</p> <pre><code>docker compose run --rm backend pnpm run generate:openapi\ndocker compose run --rm frontend sh -c 'OPENAPI_SPEC_PATH=/spec/openapi.json pnpm exec openapi-ts'\n</code></pre>"},{"location":"architecture/overview/#websocket-events","title":"WebSocket Events","text":"<p>Socket.IO connects the browser to the backend for real-time updates. In production, the Redis adapter coordinates messages across multiple backend pods.</p> <p>Events flow through a handler registry on the frontend (<code>socket-hub/handlers/</code>). Each handler either updates the TanStack Query cache directly or invalidates it to trigger a refetch. See WebSocket Patterns for details.</p>"},{"location":"architecture/overview/#voice-video","title":"Voice &amp; Video","text":"<p>LiveKit handles all media transport. The backend generates LiveKit tokens and manages room state. Channel IDs are used as LiveKit room IDs.</p>"},{"location":"architecture/overview/#shared-package","title":"Shared Package","text":"<p><code>@kraken/shared</code> (<code>shared/src/</code>) provides type-safe contracts between frontend and backend:</p> <ul> <li>Events -- <code>ServerEvents</code> enum with all WebSocket event names</li> <li>Payloads -- TypeScript interfaces for each event's data shape</li> <li>Type maps -- Maps event names to payload types for type-safe handlers</li> </ul>"},{"location":"architecture/overview/#key-design-decisions","title":"Key Design Decisions","text":"Decision Choice Rationale Database MongoDB + Prisma Document model fits nested data (messages, spans, reactions); Prisma provides type safety State management TanStack Query v5 Server state only -- no client-side store needed; cache invalidation via WebSocket Real-time Socket.IO + Redis adapter Multi-pod scaling, automatic reconnection, room-based broadcasting Voice/Video LiveKit Open-source SFU with WebRTC, supports screen sharing and recording Auth JWT + Passport Stateless tokens, refresh token rotation, works with WebSocket Schema management <code>prisma db push</code> No migration files; direct schema sync for MongoDB"},{"location":"architecture/replay-buffer/","title":"Replay Buffer","text":"<p>Continuous screen recording during screen share sessions, allowing users to retroactively capture highlights \u2014 similar to NVIDIA ShadowPlay or Discord Clipping.</p>"},{"location":"architecture/replay-buffer/#how-it-works","title":"How it works","text":"<ol> <li>User enables replay buffer while screen sharing</li> <li>LiveKit records the last 10 minutes as HLS segments (10-second chunks) via Track Composite Egress</li> <li>User clicks \"Capture Replay\" to save the last 1, 2, 5, or 10 minutes</li> <li>Backend concatenates segments with FFmpeg (stream copy, no re-encoding) into a single MP4</li> </ol> <pre><code>graph TD\n    Browser[\"Browser&lt;br/&gt;(Screen Share)\"] --&gt;|WebRTC| LiveKit[\"LiveKit Server\"]\n    LiveKit --&gt;|\"HLS Segments&lt;br/&gt;(10s chunks)\"| Storage[\"Shared Storage&lt;br/&gt;/replay-buffer/\"]\n    Storage --&gt;|Read segments| Backend[\"Kraken Backend\"]\n    Backend --&gt;|\"FFmpeg concat&lt;br/&gt;(stream copy)\"| Replays[\"Saved Replays&lt;br/&gt;/replays/\"]\n    Backend --&gt;|File record| MongoDB[(MongoDB)]</code></pre>"},{"location":"architecture/replay-buffer/#key-details","title":"Key details","text":"<ul> <li>Egress type: Track Composite Egress (GStreamer, ~1 CPU / ~1 GB RAM per recording \u2014 no Chrome instance needed)</li> <li>Codec: H.264 video, Opus audio</li> <li>Storage: ~540 MB per active buffer (12 min @ 1080p 60fps), ~450 MB per saved 10-min clip</li> <li>Cleanup: Cron job every 5 min deletes segments older than 12 min; hourly cron stops orphaned egress sessions</li> <li>Access control: <code>ENABLE_REPLAY_BUFFER</code> permission + per-community concurrent limit (default 5) + per-user storage quota (default 5 GB)</li> <li>Shared storage required: LiveKit egress and the backend must read/write the same path \u2014 see the storage setup in Docker Compose or Kubernetes</li> </ul>"},{"location":"architecture/websocket-patterns/","title":"WebSocket Event Patterns","text":"<p>Kraken uses three distinct patterns for handling WebSocket events on the frontend. This guide defines when to use each and why.</p> <p>This is not a style preference -- each pattern exists for specific technical reasons.</p>"},{"location":"architecture/websocket-patterns/#the-three-patterns","title":"The Three Patterns","text":""},{"location":"architecture/websocket-patterns/#pattern-1-direct-cache-update-setquerydata","title":"Pattern 1: Direct Cache Update (<code>setQueryData</code>)","text":"<p>The WebSocket event carries the full data object. The frontend writes it directly into the TanStack Query cache. No HTTP refetch occurs.</p> <pre><code>// Example: messageHandlers.ts\nexport const handleNewMessage: SocketEventHandler = (payload, queryClient) =&gt; {\n  queryClient.setQueryData(queryKey, (old) =&gt; {\n    return { ...old, pages: [[payload.message, ...old.pages[0]], ...old.pages.slice(1)] };\n  });\n};\n</code></pre>"},{"location":"architecture/websocket-patterns/#pattern-2-cache-invalidation-invalidatequeries","title":"Pattern 2: Cache Invalidation (<code>invalidateQueries</code>)","text":"<p>The WebSocket event carries a minimal signal (e.g., IDs). The frontend marks the cache as stale, triggering a refetch from the REST API.</p> <pre><code>// Example: communityHandlers.ts\nexport const handleChannelCreated: SocketEventHandler = (payload, queryClient) =&gt; {\n  queryClient.invalidateQueries({\n    queryKey: channelsControllerFindAllForCommunityQueryKey({\n      path: { communityId: payload.communityId },\n    }),\n  });\n};\n</code></pre>"},{"location":"architecture/websocket-patterns/#pattern-3-ephemeral-ui-state-no-cache","title":"Pattern 3: Ephemeral UI State (no cache)","text":"<p>The event drives transient component state via <code>useServerEvent()</code>. Not registered in <code>handlerRegistry</code>. No TanStack Query involvement.</p> <pre><code>// Example: useTypingUsers.ts\nuseServerEvent(ServerEvents.USER_TYPING, (payload) =&gt; {\n  setTypingUsers((prev) =&gt; { /* local state only */ });\n});\n</code></pre>"},{"location":"architecture/websocket-patterns/#decision-framework","title":"Decision Framework","text":"<p>Ask these five questions for each new WebSocket event:</p> # Question Direct Update Invalidation 1 How often does this event fire? High: multiple times/second (messages, typing, presence) Low: minutes/hours apart (roles, settings, channels) 2 How many clients receive it simultaneously? Many: dozens/hundreds in same channel (thundering herd risk) Few: only affected users 3 Is the cache shape simple? Yes: append to list, update single field, toggle boolean No: nested structures, multiple query keys, computed fields 4 Does the user expect instant feedback? Yes: chat messages, reactions, presence No: 100-200ms delay is acceptable (admin changes, settings) 5 Does the payload contain everything needed? Yes: full object, self-contained No: server computes extra fields (counts, permissions, aggregations) <p>If most answers point to one column, use that pattern. When in doubt, default to invalidation -- it's simpler and guarantees consistency.</p>"},{"location":"architecture/websocket-patterns/#current-event-inventory","title":"Current Event Inventory","text":""},{"location":"architecture/websocket-patterns/#direct-cache-updates-high-frequency-latency-sensitive","title":"Direct Cache Updates (high-frequency, latency-sensitive)","text":"Event Handler File Why Direct <code>NEW_MESSAGE</code> / <code>NEW_DM</code> <code>messageHandlers.ts</code> High frequency, full payload, instant UX required <code>UPDATE_MESSAGE</code> <code>messageHandlers.ts</code> Full message in payload, simple find-and-replace <code>DELETE_MESSAGE</code> <code>messageHandlers.ts</code> Just needs ID to filter from list <code>REACTION_ADDED/REMOVED</code> <code>messageHandlers.ts</code> High frequency during active chat <code>MESSAGE_PINNED/UNPINNED</code> <code>messageHandlers.ts</code> Single boolean toggle on cached message <code>THREAD_REPLY_COUNT_UPDATED</code> <code>messageHandlers.ts</code> Updates metadata field on parent message <code>READ_RECEIPT_UPDATED</code> <code>messageHandlers.ts</code> Updates unread count, simple field <code>NEW_THREAD_REPLY</code> / <code>UPDATE</code> / <code>DELETE</code> <code>threadHandlers.ts</code> Same rationale as messages <code>USER_ONLINE/OFFLINE</code> <code>presenceHandlers.ts</code> Very frequent, simple boolean per user <code>NEW_NOTIFICATION</code> / <code>NOTIFICATION_READ</code> <code>notificationHandlers.ts</code> Full payload, append/update in list <code>VOICE_CHANNEL_USER_JOINED/LEFT/UPDATED</code> <code>voiceHandlers.ts</code> Hybrid: <code>setQueryData</code> if cached, <code>invalidateQueries</code> fallback <code>DM_VOICE_USER_JOINED/LEFT/UPDATED</code> <code>voiceHandlers.ts</code> Same hybrid pattern"},{"location":"architecture/websocket-patterns/#cache-invalidation-low-frequency-structural","title":"Cache Invalidation (low-frequency, structural)","text":"Event Handler File Why Invalidation <code>CHANNEL_CREATED/UPDATED/DELETED</code> <code>communityHandlers.ts</code> Affects channel list ordering, permissions, visibility <code>CHANNELS_REORDERED</code> <code>communityHandlers.ts</code> Full list structure changes <code>COMMUNITY_UPDATED/DELETED</code> <code>communityHandlers.ts</code> Affects sidebar, permissions, multiple query keys <code>MEMBER_ADDED_TO_COMMUNITY</code> <code>communityHandlers.ts</code> New community structure unknown to client <code>ROLE_CREATED/UPDATED/DELETED</code> <code>roleHandlers.ts</code> Complex permission matrix, multiple dependent caches <code>ROLE_ASSIGNED/UNASSIGNED</code> <code>roleHandlers.ts</code> Affects permissions, member list, own roles <code>USER_BANNED/KICKED</code> <code>moderationHandlers.ts</code> Membership/access changes, multiple caches <code>USER_TIMED_OUT/TIMEOUT_REMOVED</code> <code>moderationHandlers.ts</code> Member state changes <code>USER_PROFILE_UPDATED</code> <code>presenceHandlers.ts</code> Infrequent, profile cached in multiple places <code>DM_VOICE_CALL_STARTED</code> <code>voiceHandlers.ts</code> Conservative: always refetch initial state"},{"location":"architecture/websocket-patterns/#ephemeral-ui-state-no-cache","title":"Ephemeral UI State (no cache)","text":"Event Location Why Ephemeral <code>USER_TYPING</code> <code>useTypingUsers.ts</code> Transient (8s timeout), no persistence needed <code>EGRESS_SEGMENTS_READY</code> <code>TrimPreview.tsx</code> Triggers one-time refetch, not ongoing state <code>REPLAY_BUFFER_STOPPED/FAILED</code> <code>useReplayBuffer.ts</code> Session-scoped flag, resets on disconnect <code>NEW_NOTIFICATION</code> (side effects) <code>useNotificationSideEffects.ts</code> Sound/desktop notification, not data"},{"location":"architecture/websocket-patterns/#the-hybrid-pattern-voice-handlers","title":"The Hybrid Pattern (Voice Handlers)","text":"<p>Voice presence handlers demonstrate a best practice for mid-frequency events:</p> <pre><code>const existing = queryClient.getQueryData(queryKey);\nif (existing) {\n  // Cache is warm (user is viewing) -- update directly for instant UX\n  queryClient.setQueryData(queryKey, (draft) =&gt; { /* merge update */ });\n} else {\n  // Cache is cold -- just invalidate, refetch when needed\n  invalidateVoiceQueries(queryClient);\n}\n</code></pre> <p>This gives you the best of both worlds: instant updates when the user is looking, zero wasted work when they're not.</p>"},{"location":"architecture/websocket-patterns/#backend-event-emission","title":"Backend Event Emission","text":""},{"location":"architecture/websocket-patterns/#domain-events-via-eventemitter2","title":"Domain Events via EventEmitter2","text":"<p>Services that don't have <code>WebsocketService</code> injected emit domain events through <code>EventEmitter2</code>. The centralized <code>RoomSubscriptionHandler</code> translates these into WebSocket room operations.</p> <pre><code>// In the service\nthis.eventEmitter.emit(RoomEvents.COMMUNITY_UPDATED, {\n  communityId, name, description, avatar, banner,\n});\n\n// In RoomSubscriptionHandler\n@OnEvent(RoomEvents.COMMUNITY_UPDATED)\nonCommunityUpdated(event: CommunityUpdatedEvent): void {\n  this.websocketService.sendToRoom(\n    RoomName.community(event.communityId),\n    ServerEvents.COMMUNITY_UPDATED,\n    event,\n  );\n}\n</code></pre> <p>Used by: community, roles, user, membership, channel-membership, direct-messages, alias-groups</p>"},{"location":"architecture/websocket-patterns/#direct-websocketservice","title":"Direct WebsocketService","text":"<p>Gateways and services that already have <code>WebsocketService</code> may call <code>sendToRoom()</code> directly.</p> <pre><code>// In messages.gateway.ts\nthis.websocketService.sendToRoom(channelId, ServerEvents.NEW_MESSAGE, { message });\n</code></pre> <p>Used by: messages gateway, channels (hybrid), moderation (hybrid), voice-presence</p>"},{"location":"architecture/websocket-patterns/#when-to-use-which","title":"When to use which","text":"<ul> <li>New service needs to emit events? Use <code>EventEmitter2</code> + add a handler in <code>RoomSubscriptionHandler</code>.</li> <li>Already in a gateway with <code>WebsocketService</code>? Direct <code>sendToRoom()</code> is fine.</li> <li>Event requires room management (join/leave)? Must use <code>EventEmitter2</code> + <code>RoomSubscriptionHandler</code>.</li> </ul>"},{"location":"architecture/websocket-patterns/#adding-a-new-websocket-event","title":"Adding a New WebSocket Event","text":"<ol> <li>Decide the pattern using the decision framework above</li> <li>Shared types: Add <code>ServerEvents</code> enum value + payload interface in <code>@kraken/shared</code></li> <li>Backend: Emit from service (EventEmitter2) or gateway (direct)</li> <li>Frontend handler: Create handler function in <code>socket-hub/handlers/</code></li> <li>Register: Add to <code>handlerRegistry</code> in <code>handlers/index.ts</code> (skip for ephemeral events)</li> <li>For ephemeral events: Use <code>useServerEvent()</code> in the consuming component instead</li> </ol>"},{"location":"architecture/websocket-patterns/#references","title":"References","text":"<ul> <li>TKDodo -- Using WebSockets with React Query</li> <li>TanStack Query -- Query Invalidation</li> </ul>"},{"location":"contributing/","title":"Contributing","text":"<p>Thanks for your interest in contributing to Kraken! Whether it's a bug report, feature request, or code contribution, every bit helps.</p>"},{"location":"contributing/#ways-to-contribute","title":"Ways to contribute","text":"<ul> <li>Report bugs \u2014 Open a GitHub issue with reproduction steps</li> <li>Suggest features \u2014 Open a discussion or issue describing what you'd like to see</li> <li>Submit code \u2014 Fix a bug, implement a feature, or improve documentation</li> <li>Improve docs \u2014 Fix typos, clarify instructions, or add missing guides</li> </ul>"},{"location":"contributing/#getting-started","title":"Getting started","text":"<ol> <li>Fork the repository on GitHub</li> <li>Clone your fork locally</li> <li>Set up the development environment</li> <li>Create a branch for your changes</li> <li>Make your changes following the patterns in the codebase</li> <li>Test your changes \u2014 run the test suite and verify manually</li> <li>Submit a pull request against the <code>main</code> branch</li> </ol>"},{"location":"contributing/#pull-request-guidelines","title":"Pull request guidelines","text":"<ul> <li>Keep PRs focused \u2014 one feature or fix per PR</li> <li>Write descriptive commit messages</li> <li>Include tests for new features and bug fixes</li> <li>Make sure existing tests pass before submitting</li> <li>Update documentation if your changes affect user-facing behavior</li> </ul>"},{"location":"contributing/#code-style","title":"Code style","text":"<ul> <li>Backend: TypeScript with NestJS conventions, ESLint + Prettier</li> <li>Frontend: TypeScript with React, ESLint + Prettier</li> <li>Run <code>docker compose run --rm backend npm run lint</code> and <code>docker compose run --rm frontend npm run lint</code> before submitting</li> </ul>"},{"location":"contributing/#reporting-issues","title":"Reporting issues","text":"<p>When reporting a bug, include:</p> <ul> <li>Steps to reproduce</li> <li>Expected vs actual behavior</li> <li>Browser/OS/Docker version</li> <li>Relevant logs (<code>docker-compose logs backend</code> or browser console)</li> </ul>"},{"location":"contributing/#legal","title":"Legal","text":"<p>By contributing to Kraken, you agree that your contribution may be included in both open-source (AGPLv3) and commercial distributions of Kraken.</p>"},{"location":"contributing/#questions","title":"Questions?","text":"<p>Open a GitHub issue or start a discussion \u2014 we're happy to help.</p>"},{"location":"contributing/code-patterns/","title":"Code Patterns","text":"<p>Key patterns and conventions used across the Kraken codebase.</p>"},{"location":"contributing/code-patterns/#rbac-role-based-access-control","title":"RBAC (Role-Based Access Control)","text":""},{"location":"contributing/code-patterns/#controller-decorators","title":"Controller Decorators","text":"<pre><code>@RequiredActions(RbacActions.CREATE_MESSAGE)\n@RbacResource({\n  type: RbacResourceType.CHANNEL,\n  idKey: 'channelId',\n  source: ResourceIdSource.PAYLOAD,\n})\n@Post()\nasync createMessage(@Body() dto: CreateMessageDto) { ... }\n</code></pre> <p>The <code>RbacGuard</code> resolves the resource (channel -&gt; community), loads the user's roles, and checks for the required action.</p>"},{"location":"contributing/code-patterns/#resource-types","title":"Resource Types","text":"Type Resolution <code>CHANNEL</code> Looks up channel to find community <code>COMMUNITY</code> Uses community ID directly <code>INSTANCE</code> Instance-level permission check"},{"location":"contributing/code-patterns/#openapi-swagger","title":"OpenAPI / Swagger","text":""},{"location":"contributing/code-patterns/#prisma-enums-in-dtos","title":"Prisma Enums in DTOs","text":"<p>The NestJS Swagger plugin can't introspect Prisma enum types. Fix with explicit <code>@ApiProperty</code>:</p> <pre><code>import { ApiProperty } from '@nestjs/swagger';\nimport { ChannelTypeValues } from '@/common/enums/swagger-enums';\n\nexport class ChannelDto {\n  @ApiProperty({ enum: ChannelTypeValues })\n  type: ChannelType;\n}\n</code></pre> <p>For arrays: <code>@ApiProperty({ enum: RbacActionsValues, isArray: true })</code></p>"},{"location":"contributing/code-patterns/#controller-response-types","title":"Controller Response Types","text":"<p>Add <code>@ApiOkResponse({ type: FooDto })</code> (or <code>@ApiCreatedResponse</code>) so the OpenAPI spec knows the response shape. Without these, endpoints generate as <code>200: unknown</code>.</p>"},{"location":"contributing/code-patterns/#partialtype-import","title":"PartialType Import","text":"<pre><code>// CORRECT\nimport { PartialType } from '@nestjs/swagger';\n\n// WRONG - loses Swagger metadata\nimport { PartialType } from '@nestjs/mapped-types';\n</code></pre>"},{"location":"contributing/code-patterns/#regenerating-the-api-client","title":"Regenerating the API Client","text":"<p>When backend controllers or DTOs change:</p> <pre><code>docker compose run --rm backend pnpm run generate:openapi\ndocker compose run --rm frontend sh -c 'OPENAPI_SPEC_PATH=/spec/openapi.json pnpm exec openapi-ts'\n</code></pre>"},{"location":"contributing/code-patterns/#sensitive-user-fields","title":"Sensitive User Fields","text":"<p>Defense-in-depth to prevent user data leaks:</p> <ol> <li>Never return raw Prisma <code>User</code> objects -- wrap in <code>new UserEntity(user)</code> which applies <code>@Exclude()</code> decorators</li> <li>Use <code>PUBLIC_USER_SELECT</code> (<code>@/common/constants/user-select.constant</code>) instead of <code>include: { user: true }</code></li> <li>Test with <code>expectNoSensitiveUserFields()</code> when creating DTOs that include user data</li> </ol> <p>When adding new fields to the User model, update:</p> <ul> <li><code>UserEntity</code> <code>@Exclude()</code> decorators (if sensitive)</li> <li><code>SENSITIVE_USER_FIELDS</code> constant in <code>test-utils/helpers/user-dto.helper.ts</code></li> <li><code>PUBLIC_USER_SELECT</code> constant (add if public, omit if sensitive)</li> <li><code>UserFactory.buildComplete()</code> (add non-null values for testing)</li> </ul>"},{"location":"contributing/code-patterns/#websocket-events","title":"WebSocket Events","text":"<p>See the dedicated WebSocket Patterns guide.</p> <p>Quick rules:</p> <ul> <li>High-frequency + full payload -&gt; direct cache update (<code>setQueryData</code>)</li> <li>Low-frequency + structural change -&gt; cache invalidation (<code>invalidateQueries</code>)</li> <li>Transient + no persistence -&gt; ephemeral state (<code>useServerEvent</code>)</li> </ul>"},{"location":"contributing/code-patterns/#platform-separation-electron-vs-web","title":"Platform Separation (Electron vs Web)","text":""},{"location":"contributing/code-patterns/#detection","title":"Detection","text":"<pre><code>import { isElectron, isWeb, hasElectronFeature } from './utils/platform';\n</code></pre>"},{"location":"contributing/code-patterns/#guidelines","title":"Guidelines","text":"<p>Platform-specific (use hooks): Screen capture, native file access, desktop notifications, auto-updates, system tray.</p> <p>Platform-agnostic (no special handling): Voice/video (LiveKit), UI (Material-UI), state (TanStack Query), WebSocket, REST API.</p>"},{"location":"contributing/code-patterns/#rules","title":"Rules","text":"<ul> <li>Never override browser APIs globally (breaks LiveKit)</li> <li>Never scatter <code>window.electronAPI</code> checks in components</li> <li>Centralize platform logic in utility functions or hooks</li> <li>Let Electron intercept via <code>setDisplayMediaRequestHandler</code> in main process</li> </ul>"},{"location":"contributing/code-patterns/#docker-development","title":"Docker Development","text":"<p>All development uses Docker. Never run <code>pnpm</code>/<code>npm</code> commands on the host.</p> <pre><code># Backend\ndocker compose run --rm backend pnpm run test\ndocker compose run --rm backend pnpm run lint\n\n# Frontend\ndocker compose run --rm frontend pnpm run test\ndocker compose run --rm frontend pnpm run type-check\n\n# Database\ndocker compose run --rm backend pnpm run prisma    # generate + push\n</code></pre>"},{"location":"contributing/development-setup/","title":"Development Setup","text":"<p>All development is done through Docker \u2014 never run <code>pnpm</code>/<code>npm</code> commands directly on the host.</p>"},{"location":"contributing/development-setup/#prerequisites","title":"Prerequisites","text":"<ul> <li>Docker (v20+) and Docker Compose (v2+)</li> <li>Git</li> </ul>"},{"location":"contributing/development-setup/#starting-the-dev-environment","title":"Starting the dev environment","text":"<pre><code>git clone https://github.com/krakenchat/kraken.git\ncd kraken\ncp backend/env.sample backend/.env\ndocker-compose up\n</code></pre> <p>This starts all services with hot reload \u2014 changes to <code>backend/</code> and <code>frontend/</code> are automatically picked up.</p> Service URL Frontend http://localhost:5173 Backend API http://localhost:3000 MongoDB <code>localhost:27017</code> Redis <code>localhost:6379</code>"},{"location":"contributing/development-setup/#common-commands","title":"Common commands","text":""},{"location":"contributing/development-setup/#backend","title":"Backend","text":"<pre><code># Open a shell in the backend container\ndocker compose run --rm backend bash\n\n# Run tests\ndocker compose run --rm backend pnpm run test\n\n# Run a single test file\ndocker compose run --rm backend pnpm exec jest &lt;test-pattern&gt;\n\n# Lint\ndocker compose run --rm backend pnpm run lint\n\n# Build\ndocker compose run --rm backend pnpm run build\n</code></pre>"},{"location":"contributing/development-setup/#frontend","title":"Frontend","text":"<pre><code># Open a shell in the frontend container\ndocker compose run --rm frontend bash\n\n# Lint\ndocker compose run --rm frontend pnpm run lint\n\n# Build\ndocker compose run --rm frontend pnpm run build\n\n# Run tests\ndocker compose run --rm frontend pnpm run test\n</code></pre>"},{"location":"contributing/development-setup/#database-prisma","title":"Database (Prisma)","text":"<pre><code># Generate Prisma client + push schema (combined)\ndocker compose run --rm backend pnpm run prisma\n\n# Generate Prisma client only\ndocker compose run --rm backend pnpm run prisma:generate\n\n# Push schema to database only\ndocker compose run --rm backend pnpm run prisma:push\n\n# Open Prisma Studio (database browser)\ndocker compose run --rm -p 5555:5555 backend npx prisma studio\n</code></pre>"},{"location":"contributing/development-setup/#docker","title":"Docker","text":"<pre><code># Start all services in background\ndocker-compose up -d\n\n# Stop all services\ndocker-compose down\n\n# View logs for a specific service\ndocker-compose logs backend -f\n\n# Rebuild containers (after Dockerfile changes)\ndocker-compose build --no-cache\n\n# Full reset (removes all data)\ndocker-compose down -v &amp;&amp; docker-compose build --no-cache &amp;&amp; docker-compose up\n</code></pre>"},{"location":"contributing/development-setup/#regenerating-the-api-client","title":"Regenerating the API client","text":"<p>When backend controllers or DTOs change, regenerate the frontend API client:</p> <pre><code># 1. Generate the OpenAPI spec\ndocker compose run --rm backend pnpm run generate:openapi\n\n# 2. Regenerate the frontend SDK\ndocker compose run --rm frontend sh -c 'OPENAPI_SPEC_PATH=/spec/openapi.json pnpm exec openapi-ts'\n</code></pre> <p>The backend directory is mounted at <code>/spec</code> inside the frontend container. The generated client goes to <code>frontend/src/api-client/</code> (gitignored \u2014 regenerated at build time).</p> <p>Note</p> <p>Always use generated SDK functions (e.g., <code>voicePresenceControllerJoinPresence(...)</code>) instead of raw <code>client.post()</code> calls.</p>"},{"location":"contributing/development-setup/#testing","title":"Testing","text":""},{"location":"contributing/development-setup/#backend-tests","title":"Backend tests","text":"<ul> <li>Framework: Jest with <code>@suites/unit</code> TestBed automocks</li> <li>Test files: <code>*.spec.ts</code> alongside source files</li> <li>E2E tests: <code>backend/test/</code> directory</li> </ul> <pre><code>docker compose run --rm backend pnpm run test        # All unit tests\ndocker compose run --rm backend pnpm run test:e2e     # E2E tests\ndocker compose run --rm backend pnpm run test -- --coverage  # With coverage\n</code></pre>"},{"location":"contributing/development-setup/#frontend-tests","title":"Frontend tests","text":"<ul> <li>Framework: Vitest + jsdom + Testing Library + MSW v2</li> <li>Test files: <code>frontend/src/__tests__/</code></li> </ul> <pre><code>docker compose run --rm frontend pnpm run test       # All tests\ndocker compose run --rm frontend pnpm run test:cov   # With coverage\n</code></pre>"},{"location":"contributing/development-setup/#project-structure","title":"Project structure","text":"<pre><code>kraken/\n\u251c\u2500\u2500 backend/\n\u2502   \u251c\u2500\u2500 src/           # NestJS application (modules, services, controllers)\n\u2502   \u251c\u2500\u2500 prisma/        # Database schema (single schema.prisma for MongoDB)\n\u2502   \u2514\u2500\u2500 test/          # E2E tests\n\u251c\u2500\u2500 frontend/\n\u2502   \u251c\u2500\u2500 src/           # React application\n\u2502   \u2514\u2500\u2500 electron/      # Electron desktop app\n\u251c\u2500\u2500 shared/            # Shared types and utilities (mounted in both containers)\n\u251c\u2500\u2500 helm/              # Kubernetes Helm chart\n\u251c\u2500\u2500 docs-site/         # Documentation site (MkDocs Material)\n\u2514\u2500\u2500 docker-compose.yml\n</code></pre>"},{"location":"contributing/development-setup/#troubleshooting","title":"Troubleshooting","text":""},{"location":"contributing/development-setup/#services-not-starting","title":"Services not starting","text":"<pre><code>docker-compose down\ndocker-compose build --no-cache\ndocker-compose up\n</code></pre>"},{"location":"contributing/development-setup/#database-connection-issues","title":"Database connection issues","text":"<p>Check that the MongoDB container is healthy:</p> <pre><code>docker-compose ps\n</code></pre>"},{"location":"contributing/development-setup/#port-conflicts","title":"Port conflicts","text":"<p>Ensure ports 3000, 5173, 27017, and 6379 are available. Stop any conflicting services or change the ports in <code>docker-compose.yml</code>.</p>"},{"location":"contributing/testing/","title":"Testing Guide","text":""},{"location":"contributing/testing/#backend-tests","title":"Backend Tests","text":"<p>Stack: Jest + <code>@suites/unit</code> TestBed automocks</p> <p>Test files live alongside source files as <code>*.spec.ts</code>. E2E tests are in <code>backend/test/</code>.</p> <pre><code># All unit tests\ndocker compose run --rm backend pnpm run test\n\n# E2E tests\ndocker compose run --rm backend pnpm run test:e2e\n\n# Single test file\ndocker compose run --rm backend pnpm exec jest &lt;test-pattern&gt;\n\n# With coverage\ndocker compose run --rm backend pnpm run test -- --coverage\n</code></pre>"},{"location":"contributing/testing/#backend-test-patterns","title":"Backend Test Patterns","text":"<p><code>@suites/unit</code> auto-mocks all dependencies injected into the service under test:</p> <pre><code>import { TestBed } from '@suites/unit';\n\ndescribe('MessagesService', () =&gt; {\n  let service: MessagesService;\n  let prisma: Mocked&lt;DatabaseService&gt;;\n\n  beforeAll(async () =&gt; {\n    const { unit, unitRef } = await TestBed.create(MessagesService).compile();\n    service = unit;\n    prisma = unitRef.get(DatabaseService);\n  });\n\n  it('should create a message', async () =&gt; {\n    prisma.message.create.mockResolvedValue(mockMessage);\n    const result = await service.create(dto);\n    expect(result).toEqual(mockMessage);\n  });\n});\n</code></pre>"},{"location":"contributing/testing/#sensitive-user-fields","title":"Sensitive User Fields","text":"<p>When creating DTOs that include user data, test with <code>expectNoSensitiveUserFields()</code>:</p> <pre><code>import { expectNoSensitiveUserFields } from '@/test-utils';\n\nit('should not expose sensitive fields', () =&gt; {\n  expectNoSensitiveUserFields(response.user);\n});\n</code></pre>"},{"location":"contributing/testing/#frontend-tests","title":"Frontend Tests","text":"<p>Stack: Vitest + jsdom + Testing Library + MSW v2</p> <p>Test files live in <code>frontend/src/__tests__/</code> organized by type: <code>components/</code>, <code>hooks/</code>, <code>features/</code>.</p> <pre><code># All tests\ndocker compose run --rm frontend pnpm run test\n\n# With coverage\ndocker compose run --rm frontend pnpm run test:cov\n</code></pre>"},{"location":"contributing/testing/#test-infrastructure","title":"Test Infrastructure","text":"<p>Located in <code>frontend/src/__tests__/test-utils/</code>:</p> <p><code>renderWithProviders()</code> wraps components with QueryClient, MemoryRouter, ThemeProvider, SocketContext, and NotificationProvider:</p> <pre><code>import { renderWithProviders } from '../test-utils';\n\nit('renders channel list', async () =&gt; {\n  const { user, queryClient } = renderWithProviders(&lt;ChannelList /&gt;);\n  // `user` is a userEvent instance for realistic interactions\n  await user.click(screen.getByText('general'));\n});\n</code></pre> <p><code>factories.ts</code> provides factory functions:</p> <pre><code>import { createMessage, createChannel, createUser, createDmGroup } from '../test-utils/factories';\n\nconst message = createMessage({ content: 'hello' });\nconst channel = createChannel({ name: 'general', type: 'TEXT' });\n</code></pre> <p><code>msw/handlers.ts</code> provides default MSW request handlers for auth, user profile, channels, and DMs. Override per-test with <code>server.use(...)</code>.</p>"},{"location":"contributing/testing/#frontend-test-patterns","title":"Frontend Test Patterns","text":""},{"location":"contributing/testing/#mock-api-client","title":"Mock API Client","text":"<pre><code>vi.mock('../../api-client/client.gen', async (importOriginal) =&gt; {\n  const { createClient, createConfig } = await importOriginal();\n  return {\n    ...await importOriginal(),\n    client: createClient(createConfig({ baseUrl: 'http://localhost:3000' })),\n  };\n});\n</code></pre> <p>This lets MSW intercept requests from the generated client.</p>"},{"location":"contributing/testing/#mock-hooks","title":"Mock Hooks","text":"<pre><code>vi.mock('../../hooks/useFoo', () =&gt; ({\n  useFoo: vi.fn(() =&gt; mockValue),\n}));\n</code></pre> <p>Warning</p> <p><code>vi.clearAllMocks()</code> does not reset <code>mockReturnValue</code>. If any test overrides a mock, reset it explicitly in <code>beforeEach</code>.</p>"},{"location":"contributing/testing/#mock-react-router","title":"Mock React Router","text":"<pre><code>vi.mock('react-router-dom', async (importOriginal) =&gt; ({\n  ...await importOriginal(),\n  useParams: vi.fn(() =&gt; ({ channelId: '123' })),\n  useNavigate: vi.fn(() =&gt; mockNavigate),\n}));\n</code></pre>"},{"location":"contributing/testing/#test-async-error-flows","title":"Test Async Error Flows","text":"<pre><code>it('shows error on failure', async () =&gt; {\n  mockMutationFn.mockRejectedValue(new Error('Network error'));\n  const { user } = renderWithProviders(&lt;MyComponent /&gt;);\n\n  await user.click(screen.getByRole('button', { name: 'Submit' }));\n\n  expect(await screen.findByText('Network error')).toBeInTheDocument();\n});\n</code></pre>"},{"location":"contributing/testing/#what-to-test","title":"What to Test","text":"<ul> <li>Components: Rendering, user interactions, conditional display</li> <li>Hooks: State changes, side effects, return values</li> <li>Action functions: API calls, error handling, cache updates</li> <li>Mock external dependencies to isolate the unit under test</li> </ul>"},{"location":"installation/configuration/","title":"Configuration","text":"<p>Kraken is configured through environment variables. The backend reads from <code>backend/.env</code> and the frontend from <code>frontend/.env</code>.</p>"},{"location":"installation/configuration/#backend-environment-variables","title":"Backend environment variables","text":"<p>Copy <code>backend/env.sample</code> to <code>backend/.env</code> to get started.</p>"},{"location":"installation/configuration/#core","title":"Core","text":"Variable Description Default <code>MONGODB_URL</code> MongoDB connection string (must include <code>replicaSet=rs0</code>) <code>mongodb://mongo:27017/kraken?replicaSet=rs0&amp;retryWrites=true&amp;w=majority&amp;directConnection=true</code> <code>JWT_SECRET</code> Secret key for signing access tokens (must change) <code>JWT_REFRESH_SECRET</code> Secret key for signing refresh tokens (must change) <code>REDIS_HOST</code> Redis hostname <code>redis</code> <p>Change the JWT secrets</p> <p>The default secrets in <code>env.sample</code> are placeholders. Always generate strong random values for production: <pre><code>openssl rand -base64 32\n</code></pre></p>"},{"location":"installation/configuration/#livekit-voicevideo","title":"LiveKit (voice/video)","text":"<p>These are optional \u2014 voice and video features are disabled if not configured.</p> Variable Description Example <code>LIVEKIT_URL</code> LiveKit server URL returned to the browser for WebRTC connections <code>wss://your-livekit-server.com</code> <code>LIVEKIT_INTERNAL_URL</code> (Optional) Internal URL for server-to-server LiveKit API calls. Falls back to <code>LIVEKIT_URL</code> if not set. Useful when LiveKit is on a Docker network (e.g., <code>http://livekit:7880</code>) while browsers need a different URL. <code>http://livekit:7880</code> <code>LIVEKIT_API_KEY</code> LiveKit API key <code>your-api-key</code> <code>LIVEKIT_API_SECRET</code> LiveKit API secret <code>your-api-secret</code> <code>LIVEKIT_WEBHOOK_SECRET</code> Secret for verifying LiveKit webhook payloads <code>your-webhook-secret</code>"},{"location":"installation/configuration/#replay-buffer","title":"Replay buffer","text":"<p>Configuration for the replay buffer / screen recording feature. Requires LiveKit egress to be set up.</p> Variable Description Default <code>REPLAY_SEGMENTS_PATH</code> Backend storage path for replay metadata <code>/app/storage/replay-segments</code> <code>REPLAY_EGRESS_OUTPUT_PATH</code> LiveKit egress output path (must be accessible by egress pods) <code>/out</code> <code>REPLAY_SEGMENT_CLEANUP_AGE_MINUTES</code> How long to keep replay segments before cleanup <code>20</code>"},{"location":"installation/configuration/#push-notifications-vapid","title":"Push notifications (VAPID)","text":"<p>Web Push notifications require VAPID keys. Each instance needs its own unique key pair.</p> Variable Description Example <code>VAPID_PUBLIC_KEY</code> VAPID public key (generate with command below) <code>VAPID_PRIVATE_KEY</code> VAPID private key (generate with command below) <code>VAPID_SUBJECT</code> Contact email for VAPID <code>mailto:admin@your-instance.com</code> <p>Generate VAPID keys:</p> <pre><code>docker compose run --rm backend npx web-push generate-vapid-keys\n</code></pre>"},{"location":"installation/configuration/#frontend-environment-variables","title":"Frontend environment variables","text":"<p>Copy <code>frontend/.env.sample</code> to <code>frontend/.env</code>. The defaults work for local Docker development.</p> Variable Description Default <code>VITE_API_URL</code> Backend API URL (Vite proxies this in dev; nginx proxies in production) <code>/api</code> <code>VITE_WS_URL</code> WebSocket URL for Socket.IO <code>http://localhost:3000</code>"},{"location":"installation/configuration/#telemetry-optional","title":"Telemetry (optional)","text":"Variable Description <code>VITE_TELEMETRY_ENDPOINT</code> OpenObserve instance URL <code>VITE_TELEMETRY_CLIENT_TOKEN</code> OpenObserve client token <code>VITE_TELEMETRY_ORG_ID</code> OpenObserve organization ID <code>VITE_APP_VERSION</code> App version reported to telemetry <p>Leave telemetry variables blank to disable.</p>"},{"location":"installation/configuration/#production-considerations","title":"Production considerations","text":"<ul> <li>JWT secrets \u2014 Use long, random strings. Never reuse across environments.</li> <li>MongoDB \u2014 Use a replica set with authentication enabled. Restrict network access.</li> <li>Redis \u2014 Enable authentication and restrict network access.</li> <li>HTTPS \u2014 Always use TLS in production. Configure via your reverse proxy or Kubernetes ingress.</li> <li>VAPID keys \u2014 Generate once per instance and keep stable. Changing them invalidates existing push subscriptions.</li> </ul>"},{"location":"installation/desktop-app/","title":"Desktop App","text":"<p>Kraken provides an Electron-based desktop app for Windows and Linux with native features like system tray integration, auto-updates, and enhanced screen sharing.</p>"},{"location":"installation/desktop-app/#download","title":"Download","text":"<p>Download the latest release for your platform from GitHub Releases.</p> Platform Format File Windows NSIS installer <code>Kraken-Setup-X.X.X.exe</code> Linux Universal binary <code>Kraken-X.X.X.AppImage</code> Linux Debian/Ubuntu <code>kraken_X.X.X_amd64.deb</code> Linux Fedora/RHEL <code>kraken-X.X.X.x86_64.rpm</code> <p>macOS</p> <p>macOS builds are not yet available. macOS support is planned for a future release.</p>"},{"location":"installation/desktop-app/#install","title":"Install","text":"WindowsLinux (AppImage)Linux (Debian/Ubuntu)Linux (Fedora/RHEL) <ol> <li>Download <code>Kraken-Setup-X.X.X.exe</code> from Releases</li> <li>Run the installer \u2014 you can choose the install directory</li> <li>Launch Kraken from the Start Menu or desktop shortcut</li> </ol> <ol> <li>Download <code>Kraken-X.X.X.AppImage</code> from Releases</li> <li>Make it executable and run:     <pre><code>chmod +x Kraken-*.AppImage\n./Kraken-*.AppImage\n</code></pre></li> </ol> <pre><code>sudo dpkg -i kraken_*_amd64.deb\nsudo apt-get install -f  # resolve any missing dependencies\n</code></pre> <pre><code>sudo rpm -i kraken-*.x86_64.rpm\n</code></pre>"},{"location":"installation/desktop-app/#connect-to-your-instance","title":"Connect to your instance","text":"<p>On first launch, Kraken will prompt you to enter your server URL (e.g. <code>https://kraken.example.com</code>). This is the address where your self-hosted Kraken instance is running.</p>"},{"location":"installation/desktop-app/#auto-updates","title":"Auto-updates","text":"<p>The desktop app checks for updates automatically on startup and periodically while running. When a new version is available, you'll see a notification with the option to install and restart.</p> <p>Updates are served from GitHub Releases \u2014 no additional infrastructure required.</p>"},{"location":"installation/desktop-app/#desktop-only-features","title":"Desktop-only features","text":"<p>The desktop app includes capabilities not available in the browser:</p> <ul> <li>Screen source picker \u2014 choose specific windows or monitors to share (on X11)</li> <li>System audio capture \u2014 share desktop audio during screen sharing (Windows)</li> <li>System tray \u2014 minimize to tray, quick access controls</li> <li>Auto-start \u2014 optionally launch Kraken on system startup</li> <li>Native notifications \u2014 OS-level notification integration</li> </ul>"},{"location":"installation/docker-compose/","title":"Docker Compose","text":"<p>Deploy Kraken with Docker Compose \u2014 from first launch to production.</p>"},{"location":"installation/docker-compose/#prerequisites","title":"Prerequisites","text":"<ul> <li>Docker (v20+) and Docker Compose (v2+)</li> </ul>"},{"location":"installation/docker-compose/#choose-your-livekit-setup","title":"Choose your LiveKit setup","text":"<p>Kraken uses LiveKit for voice and video. Pick the option that fits your situation:</p> Batteries included (recommended)Bring your own LiveKit <p>Bundles a local LiveKit server so voice and video work out of the box \u2014 nothing else to install.</p> <p>Use this if you already run LiveKit (self-hosted or LiveKit Cloud). Voice/video are disabled until you add your credentials.</p>"},{"location":"installation/docker-compose/#install","title":"Install","text":""},{"location":"installation/docker-compose/#1-create-the-compose-file","title":"1. Create the Compose file","text":"<pre><code>mkdir kraken &amp;&amp; cd kraken\n</code></pre> <p>Copy the Compose file for your chosen setup:</p> Batteries included (recommended)Bring your own LiveKit docker-compose.yml<pre><code>services:\n  backend:\n    image: ghcr.io/krakenchat/kraken-backend:latest\n    ports:\n      - \"3000:3000\"\n    environment:\n      MONGODB_URL: mongodb://mongo:27017/kraken?replicaSet=rs0&amp;retryWrites=true&amp;w=majority&amp;directConnection=true\n      REDIS_HOST: redis\n      JWT_SECRET: ${JWT_SECRET:?Set JWT_SECRET in .env}\n      JWT_REFRESH_SECRET: ${JWT_REFRESH_SECRET:?Set JWT_REFRESH_SECRET in .env}\n      LIVEKIT_URL: ws://localhost:7880\n      LIVEKIT_INTERNAL_URL: http://livekit:7880\n      LIVEKIT_API_KEY: devkey\n      LIVEKIT_API_SECRET: secret-that-is-at-least-32-characters-long\n    depends_on:\n      mongo:\n        condition: service_healthy\n      redis:\n        condition: service_healthy\n      livekit:\n        condition: service_started\n\n  frontend:\n    image: ghcr.io/krakenchat/kraken-frontend:latest\n    ports:\n      - \"5173:5173\"\n    environment:\n      BACKEND_URL: http://backend:3000\n    depends_on:\n      - backend\n\n  livekit:\n    image: livekit/livekit-server:latest\n    environment:\n      LIVEKIT_CONFIG: |\n        port: 7880\n        rtc:\n          tcp_port: 7881\n          port_range_start: 50000\n          port_range_end: 50060\n          use_external_ip: false\n          node_ip: 127.0.0.1\n        keys:\n          devkey: secret-that-is-at-least-32-characters-long\n        webhook:\n          api_key: devkey\n          urls:\n            - http://backend:3000/api/livekit/webhook\n    ports:\n      - \"7880:7880\"\n      - \"7881:7881\"\n      - \"50000-50060:50000-50060/udp\"\n\n  mongo:\n    image: mongo:7.0\n    command: [\"--replSet\", \"rs0\", \"--bind_ip_all\", \"--port\", \"27017\"]\n    ports:\n      - \"27017:27017\"\n    healthcheck:\n      test: echo \"try { rs.status() } catch (err) { rs.initiate({_id:'rs0',members:[{_id:0,host:'mongo:27017'}]}) }\" | mongosh --port 27017 --quiet\n      interval: 5s\n      timeout: 30s\n      start_period: 0s\n      start_interval: 1s\n      retries: 30\n    volumes:\n      - mongodata:/data/db\n      - mongodb_config:/data/configdb\n\n  redis:\n    image: redis:latest\n    ports:\n      - \"6379:6379\"\n    healthcheck:\n      test: [\"CMD\", \"redis-cli\", \"ping\"]\n      interval: 5s\n      timeout: 10s\n      retries: 10\n    volumes:\n      - redisdata:/data\n\nvolumes:\n  mongodata:\n  mongodb_config:\n  redisdata:\n</code></pre> <p>What's in the LiveKit config:</p> <ul> <li><code>node_ip: 127.0.0.1</code> \u2014 tells WebRTC clients to connect via localhost (required for Docker port forwarding)</li> <li><code>use_external_ip: false</code> \u2014 disables STUN-based IP discovery (not needed locally)</li> <li><code>keys</code> \u2014 the API key/secret pair must match what the backend uses, and the secret must be at least 32 characters or LiveKit will refuse to start</li> <li><code>webhook</code> \u2014 pre-configured to send voice presence events back to the backend (requires <code>api_key</code> to sign payloads)</li> <li><code>LIVEKIT_INTERNAL_URL</code> \u2014 the backend uses this Docker-internal address for server-to-server API calls (room management, muting), while <code>LIVEKIT_URL</code> is the browser-facing address returned to clients</li> </ul> docker-compose.yml<pre><code>services:\n  backend:\n    image: ghcr.io/krakenchat/kraken-backend:latest\n    ports:\n      - \"3000:3000\"\n    environment:\n      MONGODB_URL: mongodb://mongo:27017/kraken?replicaSet=rs0&amp;retryWrites=true&amp;w=majority&amp;directConnection=true\n      REDIS_HOST: redis\n      JWT_SECRET: ${JWT_SECRET:?Set JWT_SECRET in .env}\n      JWT_REFRESH_SECRET: ${JWT_REFRESH_SECRET:?Set JWT_REFRESH_SECRET in .env}\n      # Uncomment and fill in to enable voice/video:\n      # LIVEKIT_URL: ${LIVEKIT_URL:-}\n      # LIVEKIT_API_KEY: ${LIVEKIT_API_KEY:-}\n      # LIVEKIT_API_SECRET: ${LIVEKIT_API_SECRET:-}\n    depends_on:\n      mongo:\n        condition: service_healthy\n      redis:\n        condition: service_healthy\n\n  frontend:\n    image: ghcr.io/krakenchat/kraken-frontend:latest\n    ports:\n      - \"5173:5173\"\n    environment:\n      BACKEND_URL: http://backend:3000\n    depends_on:\n      - backend\n\n  mongo:\n    image: mongo:7.0\n    command: [\"--replSet\", \"rs0\", \"--bind_ip_all\", \"--port\", \"27017\"]\n    ports:\n      - \"27017:27017\"\n    healthcheck:\n      test: echo \"try { rs.status() } catch (err) { rs.initiate({_id:'rs0',members:[{_id:0,host:'mongo:27017'}]}) }\" | mongosh --port 27017 --quiet\n      interval: 5s\n      timeout: 30s\n      start_period: 0s\n      start_interval: 1s\n      retries: 30\n    volumes:\n      - mongodata:/data/db\n      - mongodb_config:/data/configdb\n\n  redis:\n    image: redis:latest\n    ports:\n      - \"6379:6379\"\n    healthcheck:\n      test: [\"CMD\", \"redis-cli\", \"ping\"]\n      interval: 5s\n      timeout: 10s\n      retries: 10\n    volumes:\n      - redisdata:/data\n\nvolumes:\n  mongodata:\n  mongodb_config:\n  redisdata:\n</code></pre> <p>To enable voice/video later, uncomment the <code>LIVEKIT_*</code> lines and add your credentials to <code>.env</code>. See Connecting your LiveKit server below.</p>"},{"location":"installation/docker-compose/#2-configure-environment","title":"2. Configure environment","text":"<p>Create a <code>.env</code> file next to your <code>docker-compose.yml</code>:</p> Batteries included (recommended)Bring your own LiveKit .env<pre><code>JWT_SECRET=replace-with-a-long-random-string\nJWT_REFRESH_SECRET=replace-with-a-different-long-random-string\n</code></pre> .env<pre><code>JWT_SECRET=replace-with-a-long-random-string\nJWT_REFRESH_SECRET=replace-with-a-different-long-random-string\n\n# Uncomment to enable voice/video:\n# LIVEKIT_URL=wss://your-livekit-server.com\n# LIVEKIT_API_KEY=your-api-key\n# LIVEKIT_API_SECRET=your-api-secret\n</code></pre> <p>Generate strong JWT secrets with:</p> <pre><code>openssl rand -base64 32\n</code></pre> <p>Security</p> <p>Never use the default secrets in production. Generate unique values for each secret.</p> <p>See the Configuration page for the full environment variable reference.</p>"},{"location":"installation/docker-compose/#3-start-all-services","title":"3. Start all services","text":"<pre><code>docker compose up\n</code></pre> Batteries included (recommended)Bring your own LiveKit Service Description URL Frontend Nginx serving the React app http://localhost:5173 Backend NestJS API http://localhost:3000 LiveKit Voice/video media server <code>ws://localhost:7880</code> MongoDB Database (replica set) <code>localhost:27017</code> Redis Cache and pub/sub <code>localhost:6379</code> Service Description URL Frontend Nginx serving the React app http://localhost:5173 Backend NestJS API http://localhost:3000 MongoDB Database (replica set) <code>localhost:27017</code> Redis Cache and pub/sub <code>localhost:6379</code>"},{"location":"installation/docker-compose/#4-initialize-the-database","title":"4. Initialize the database","text":"<p>On first run, push the Prisma schema to MongoDB:</p> <pre><code>docker compose exec backend npx prisma db push --schema=prisma/schema.prisma\n</code></pre>"},{"location":"installation/docker-compose/#5-open-kraken","title":"5. Open Kraken","text":"<p>Visit http://localhost:5173 in your browser. You're ready to create your first account.</p>"},{"location":"installation/docker-compose/#stopping-and-restarting","title":"Stopping and restarting","text":"<pre><code># Stop all services\ndocker compose down\n\n# Start again (data is persisted in Docker volumes)\ndocker compose up\n\n# Full reset (removes all data)\ndocker compose down -v\n</code></pre>"},{"location":"installation/docker-compose/#connecting-your-livekit-server","title":"Connecting your LiveKit server","text":"<p>If you chose the \"Bring your own LiveKit\" setup, follow these steps to enable voice and video.</p>"},{"location":"installation/docker-compose/#livekit-cloud","title":"LiveKit Cloud","text":"<ol> <li>Sign up at LiveKit Cloud and create a project</li> <li>Add credentials to your <code>.env</code>:     <pre><code>LIVEKIT_URL=wss://your-project.livekit.cloud\nLIVEKIT_API_KEY=your-api-key\nLIVEKIT_API_SECRET=your-api-secret\n</code></pre></li> <li>Uncomment the <code>LIVEKIT_*</code> lines in <code>docker-compose.yml</code></li> <li>Configure webhooks in the LiveKit Cloud dashboard \u2014 set the URL to <code>https://your-domain.com/api/livekit/webhook</code></li> <li>Restart: <code>docker compose down &amp;&amp; docker compose up</code></li> </ol> <p>Replay capture not yet supported with LiveKit Cloud</p> <p>The replay/clip capture feature requires LiveKit egress and Kraken to share a filesystem for HLS segment access. LiveKit Cloud writes egress output to cloud storage (S3/GCS/Azure Blob), which Kraken can't read from yet. Voice and video calls work normally \u2014 only replay capture is affected. See #227 for progress on cloud storage support.</p>"},{"location":"installation/docker-compose/#self-hosted-livekit","title":"Self-hosted LiveKit","text":"<ol> <li>Add credentials to your <code>.env</code>:     <pre><code>LIVEKIT_URL=wss://your-livekit-server.com\nLIVEKIT_API_KEY=your-api-key\nLIVEKIT_API_SECRET=your-api-secret\n</code></pre></li> <li>Uncomment the <code>LIVEKIT_*</code> lines in <code>docker-compose.yml</code></li> <li>Configure webhooks on your LiveKit server to send events to <code>https://your-domain.com/api/livekit/webhook</code></li> <li>Restart: <code>docker compose down &amp;&amp; docker compose up</code></li> </ol> <p>When browser and backend URLs differ</p> <p>If the backend can't reach LiveKit at the same URL the browser uses (e.g., different networks), set <code>LIVEKIT_INTERNAL_URL</code> to the backend-reachable address. The backend uses this for server-to-server API calls while <code>LIVEKIT_URL</code> is returned to browsers. See the Configuration page for details.</p>"},{"location":"installation/docker-compose/#going-to-production","title":"Going to production","text":""},{"location":"installation/docker-compose/#architecture-overview","title":"Architecture overview","text":"<pre><code>graph LR\n    Client[Browser] --&gt; Proxy[Reverse Proxy&lt;br/&gt;nginx / Caddy]\n    Proxy --&gt;|/| Frontend[Frontend&lt;br/&gt;React + Nginx&lt;br/&gt;:5173]\n    Proxy --&gt;|/api, /socket.io| Backend[Backend&lt;br/&gt;NestJS&lt;br/&gt;:3000]\n    Backend --&gt; MongoDB[(MongoDB&lt;br/&gt;:27017)]\n    Backend --&gt; Redis[(Redis&lt;br/&gt;:6379)]\n    Backend --&gt; LiveKit[LiveKit Server]</code></pre> <p>For production, update your Compose file with <code>restart: unless-stopped</code> on every service, and start in detached mode:</p> <pre><code>docker compose up -d\n</code></pre> <p>Change all default secrets</p> <p>Generate unique random values for every secret. Never commit <code>.env</code> files to version control.</p>"},{"location":"installation/docker-compose/#reverse-proxy-and-https","title":"Reverse proxy and HTTPS","text":"<p>Place a reverse proxy (nginx, Caddy, or Traefik) in front of Kraken to handle TLS termination:</p> <ul> <li>Proxy <code>your-domain.com</code> to the frontend (port 5173)</li> <li>Proxy <code>your-domain.com/api</code> to the backend (port 3000)</li> <li>Ensure WebSocket upgrade headers are forwarded for Socket.IO</li> </ul>"},{"location":"installation/docker-compose/#data-persistence","title":"Data persistence","text":"<p>Docker Compose uses named volumes for MongoDB and Redis data. These persist across container restarts.</p> <ul> <li>Backup MongoDB regularly: <code>docker compose exec mongo mongodump --out /backup</code></li> <li>Monitor disk usage \u2014 MongoDB and uploads can grow over time</li> </ul>"},{"location":"installation/docker-compose/#resource-limits","title":"Resource limits","text":"<p>For production, consider adding resource limits in a <code>docker-compose.override.yml</code>:</p> <pre><code>services:\n  backend:\n    deploy:\n      resources:\n        limits:\n          memory: 1G\n  frontend:\n    deploy:\n      resources:\n        limits:\n          memory: 512M\n</code></pre>"},{"location":"installation/docker-compose/#networking","title":"Networking","text":"<ul> <li>MongoDB and Redis should not be exposed to the public internet \u2014 remove their <code>ports</code> mappings or bind to <code>127.0.0.1</code></li> <li>Only expose the frontend and backend through your reverse proxy</li> <li>Consider Docker networks to isolate services</li> </ul>"},{"location":"installation/docker-compose/#replay-capture-livekit-egress","title":"Replay capture (LiveKit egress)","text":"<p>The replay/clip capture feature requires LiveKit egress to write HLS segments to a location that the Kraken backend can also read from. Both services need access to the same storage path.</p> <p>Mount a shared volume into both the LiveKit egress container and the Kraken backend:</p> <pre><code>services:\n  backend:\n    volumes:\n      - egress-data:/out\n    environment:\n      REPLAY_EGRESS_OUTPUT_PATH: /out\n      REPLAY_SEGMENTS_PATH: /out\n\n  # Your LiveKit egress service must also mount egress-data:/out\n\nvolumes:\n  egress-data:\n</code></pre> <p>LiveKit Cloud</p> <p>LiveKit Cloud writes egress output to cloud storage (S3/GCS/Azure Blob), which Kraken can't read from yet. Replay capture is not available with LiveKit Cloud until cloud storage support is added. See #227 for progress.</p>"},{"location":"installation/docker-compose/#updating","title":"Updating","text":"<pre><code>docker compose pull\ndocker compose up -d\n\n# Run any database schema updates\ndocker compose exec backend npx prisma db push --schema=prisma/schema.prisma\n</code></pre>"},{"location":"installation/docker-compose/#troubleshooting","title":"Troubleshooting","text":""},{"location":"installation/docker-compose/#replica-set-not-initialized","title":"\"Replica set not initialized\"","text":"<p>The Docker Compose setup automatically configures the MongoDB replica set. If you see this error, restart the containers:</p> <pre><code>docker compose down &amp;&amp; docker compose up\n</code></pre>"},{"location":"installation/docker-compose/#port-already-in-use","title":"\"Port already in use\"","text":"<p>Check what's using the port and stop it:</p> <pre><code>lsof -i :3000  # Backend\nlsof -i :5173  # Frontend\nlsof -i :7880  # LiveKit\n</code></pre>"},{"location":"installation/docker-compose/#livekit-exits-immediately","title":"LiveKit exits immediately","text":"<p>Check the logs:</p> <pre><code>docker compose logs livekit\n</code></pre> <p>Common causes:</p> <ul> <li>\"secret is too short\" \u2014 The API secret in the <code>LIVEKIT_CONFIG</code> keys section and in the backend's <code>LIVEKIT_API_SECRET</code> must be at least 32 characters. Both values must match.</li> <li>\"api_key is required to use webhooks\" \u2014 The <code>webhook</code> section in <code>LIVEKIT_CONFIG</code> needs an <code>api_key</code> field matching one of the keys defined in the <code>keys</code> section.</li> </ul>"},{"location":"installation/docker-compose/#prisma-client-not-generated","title":"\"Prisma client not generated\"","text":"<p>Run the schema push again:</p> <pre><code>docker compose exec backend npx prisma db push --schema=prisma/schema.prisma\n</code></pre>"},{"location":"installation/docker-compose/#containers-wont-start","title":"Containers won't start","text":"<p>Try pulling fresh images and recreating:</p> <pre><code>docker compose down -v\ndocker compose pull\ndocker compose up\n</code></pre>"},{"location":"installation/docker-compose/#next-steps","title":"Next steps","text":"<ul> <li>Configuration \u2014 Full environment variable reference</li> <li>First Run \u2014 Create your first user, community, and channels</li> <li>Kubernetes \u2014 Deploy to a Kubernetes cluster</li> </ul>"},{"location":"installation/first-run/","title":"First Run","text":"<p>After installing Kraken, follow these steps to set up your instance.</p>"},{"location":"installation/first-run/#1-register-your-account","title":"1. Register your account","text":"<p>Open http://localhost:5173 and create a new account. The first user registered on a fresh instance can be promoted to instance admin.</p>"},{"location":"installation/first-run/#2-create-a-community","title":"2. Create a community","text":"<ol> <li>Click the + button in the sidebar</li> <li>Enter a community name and optional description</li> <li>Click Create</li> </ol> <p>Your new community appears in the sidebar \u2014 similar to a Discord server.</p>"},{"location":"installation/first-run/#3-create-channels","title":"3. Create channels","text":"<p>Inside your community:</p> <ol> <li>Click the + next to the channel list</li> <li>Choose a channel type:<ul> <li>Text \u2014 for messaging</li> <li>Voice \u2014 for voice and video calls (requires LiveKit configuration)</li> </ul> </li> <li>Name the channel and click Create</li> </ol>"},{"location":"installation/first-run/#4-invite-others","title":"4. Invite others","text":"<ol> <li>Open your community settings</li> <li>Go to the Invites section</li> <li>Create an invite link</li> <li>Share the link with others \u2014 they can register and join your community</li> </ol>"},{"location":"installation/first-run/#5-start-chatting","title":"5. Start chatting","text":"<ul> <li>Send messages in text channels with mentions, reactions, and file attachments</li> <li>Join voice channels for real-time audio and video (if LiveKit is configured)</li> <li>Use direct messages for private conversations</li> </ul>"},{"location":"installation/first-run/#optional-set-up-voice-and-video","title":"Optional: Set up voice and video","text":"<p>If you haven't configured LiveKit yet, voice channels will be visible but non-functional. See the LiveKit setup instructions to enable voice and video calls, including screen sharing and replay buffer features.</p>"},{"location":"installation/first-run/#next-steps","title":"Next steps","text":"<ul> <li>Configuration \u2014 Tune environment variables</li> <li>Contributing \u2014 Help improve Kraken</li> </ul>"},{"location":"installation/kubernetes/","title":"Kubernetes","text":"<p>Deploy Kraken to a Kubernetes cluster using the official Helm chart.</p>"},{"location":"installation/kubernetes/#architecture","title":"Architecture","text":"<pre><code>graph LR\n    Client[Browser] --&gt; Ingress[NGINX Ingress]\n    Ingress --&gt;|/| Frontend[Frontend&lt;br/&gt;React + Nginx]\n    Ingress --&gt;|/api, /socket.io| Backend[Backend&lt;br/&gt;NestJS]\n    Backend --&gt; MongoDB[(MongoDB&lt;br/&gt;Replica Set)]\n    Backend --&gt; Redis[(Redis)]\n    Backend --&gt; LiveKit[LiveKit Server]\n    Backend --&gt; FileStorage[(File Storage&lt;br/&gt;PVC)]</code></pre> Component Replicas Description Backend 2+ NestJS API server + Socket.IO WebSocket server Frontend 2+ Static React app served via nginx MongoDB 3 Replica set (<code>rs0</code>) \u2014 bundled or external Redis 1 Cache and Socket.IO adapter \u2014 bundled or external LiveKit external Voice/video media server (Cloud or self-hosted)"},{"location":"installation/kubernetes/#prerequisites","title":"Prerequisites","text":"<ul> <li>Kubernetes (v1.24+) \u2014 managed (GKE, EKS, AKS) or self-hosted (k3s, kubeadm)</li> <li>Helm (v3.8+)</li> <li>kubectl configured for your cluster</li> <li>NGINX Ingress Controller</li> <li>LiveKit \u2014 LiveKit Cloud or a self-hosted server</li> </ul> <p>Optional: cert-manager for automatic TLS, metrics-server for autoscaling.</p>"},{"location":"installation/kubernetes/#quick-start","title":"Quick start","text":""},{"location":"installation/kubernetes/#1-generate-secrets","title":"1. Generate secrets","text":"<pre><code>export JWT_SECRET=$(openssl rand -base64 32)\nexport JWT_REFRESH_SECRET=$(openssl rand -base64 32)\nexport MONGO_ROOT_PASSWORD=$(openssl rand -base64 32)\nexport MONGO_PASSWORD=$(openssl rand -base64 32)\nexport REDIS_PASSWORD=$(openssl rand -base64 32)\n</code></pre>"},{"location":"installation/kubernetes/#2-install-the-chart","title":"2. Install the chart","text":"<p>The simplest install uses bundled MongoDB and Redis:</p> <pre><code>helm install kraken oci://ghcr.io/krakenchat/charts/kraken \\\n  --set secrets.jwtSecret=\"$JWT_SECRET\" \\\n  --set secrets.jwtRefreshSecret=\"$JWT_REFRESH_SECRET\" \\\n  --set mongodb.auth.rootPassword=\"$MONGO_ROOT_PASSWORD\" \\\n  --set mongodb.auth.password=\"$MONGO_PASSWORD\" \\\n  --set redis.auth.password=\"$REDIS_PASSWORD\" \\\n  --set ingress.hosts[0].host=kraken.yourdomain.com \\\n  --set livekit.url=wss://your-livekit-server.com \\\n  --set livekit.apiKey=YOUR_KEY \\\n  --set livekit.apiSecret=YOUR_SECRET \\\n  --namespace kraken \\\n  --create-namespace\n</code></pre>"},{"location":"installation/kubernetes/#3-verify","title":"3. Verify","text":"<pre><code>kubectl get pods -n kraken --watch\n</code></pre> <p>Wait for all pods to show <code>Running</code>, then visit your domain.</p>"},{"location":"installation/kubernetes/#configuration","title":"Configuration","text":"<p>For anything beyond the quick start, create a values file:</p> <pre><code>helm install kraken oci://ghcr.io/krakenchat/charts/kraken \\\n  --values custom-values.yaml \\\n  --namespace kraken \\\n  --create-namespace\n</code></pre>"},{"location":"installation/kubernetes/#minimal-values-file","title":"Minimal values file","text":"custom-values.yaml<pre><code># --- Images ---\nbackend:\n  image:\n    repository: ghcr.io/krakenchat/kraken-backend\n    tag: \"latest\"\n\nfrontend:\n  image:\n    repository: ghcr.io/krakenchat/kraken-frontend\n    tag: \"latest\"\n\n# --- Secrets ---\nsecrets:\n  jwtSecret: \"\"      # Set via --set or use existingSecret\n  jwtRefreshSecret: \"\"\n\n# --- LiveKit ---\nlivekit:\n  url: \"wss://your-livekit-server.com\"\n  apiKey: \"your-api-key\"\n  apiSecret: \"your-api-secret\"\n\n# --- Ingress ---\ningress:\n  enabled: true\n  className: nginx\n  hosts:\n    - host: kraken.yourdomain.com\n      paths:\n        - path: /\n          pathType: Prefix\n          service: frontend\n        - path: /api\n          pathType: Prefix\n          service: backend\n        - path: /socket.io\n          pathType: Prefix\n          service: backend\n  tls:\n    mode: cert-manager\n    certManager:\n      issuer: letsencrypt-prod\n\n# --- Data stores (bundled by default) ---\nmongodb:\n  bundled: true\n\nredis:\n  bundled: true\n</code></pre>"},{"location":"installation/kubernetes/#ingress","title":"Ingress","text":"<p>The chart configures path-based routing through an NGINX ingress with annotations for WebSocket support (long timeouts, sticky sessions, upgrade headers). Three routes are defined:</p> Path Routes to Purpose <code>/</code> Frontend Static React app <code>/api</code> Backend REST API <code>/socket.io</code> Backend WebSocket real-time events <p>TLS modes:</p> <pre><code># Automatic with cert-manager (recommended)\ntls:\n  mode: cert-manager\n  certManager:\n    issuer: letsencrypt-prod\n\n# Existing TLS secret\ntls:\n  mode: manual\n  secretName: my-tls-secret\n\n# No TLS (dev only)\ntls:\n  mode: \"none\"\n</code></pre>"},{"location":"installation/kubernetes/#mongodb","title":"MongoDB","text":"<p>The chart bundles a Bitnami MongoDB replica set by default. For production, consider running MongoDB externally for more control:</p> Bundled (default)External <pre><code>mongodb:\n  bundled: true\n  replicaCount: 3\n  auth:\n    rootPassword: \"CHANGE-ME\"\n    password: \"CHANGE-ME\"\n  persistence:\n    size: 50Gi\n</code></pre> <pre><code>mongodb:\n  bundled: false\n  external:\n    uri: \"mongodb://user:password@mongo-host:27017/kraken?replicaSet=rs0&amp;retryWrites=true&amp;w=majority\"\n</code></pre> <p>Note</p> <p>MongoDB must run as a replica set (<code>rs0</code>). Kraken uses change streams for real-time features, which require replica set mode.</p>"},{"location":"installation/kubernetes/#redis","title":"Redis","text":"<p>Same pattern \u2014 bundled or external:</p> Bundled (default)External <pre><code>redis:\n  bundled: true\n  auth:\n    password: \"CHANGE-ME\"\n  master:\n    persistence:\n      size: 10Gi\n</code></pre> <pre><code>redis:\n  bundled: false\n  external:\n    host: \"redis.example.com\"\n    port: 6379\n    password: \"your-redis-password\"\n</code></pre>"},{"location":"installation/kubernetes/#livekit","title":"LiveKit","text":"<p>Kraken requires a LiveKit server for voice and video. The chart doesn't bundle LiveKit \u2014 use LiveKit Cloud or a self-hosted deployment.</p> <pre><code>livekit:\n  url: \"wss://your-livekit-server.com\"\n  apiKey: \"your-api-key\"\n  apiSecret: \"your-api-secret\"\n  webhookSecret: \"your-webhook-secret\"  # optional\n</code></pre> <p>Configure your LiveKit server to send webhooks to <code>https://your-domain.com/api/livekit/webhook</code> for voice presence tracking.</p> <p>Replay capture with LiveKit Cloud</p> <p>LiveKit Cloud writes egress output to cloud storage (S3/GCS/Azure Blob), which Kraken can't read from yet. Replay capture is not available with LiveKit Cloud until cloud storage support is added \u2014 voice and video calls work normally. See #227 for progress.</p>"},{"location":"installation/kubernetes/#file-storage","title":"File storage","text":"<p>User-uploaded files (avatars, attachments) need a <code>ReadWriteMany</code> PVC so all backend replicas can access them:</p> <pre><code>fileStorage:\n  enabled: true\n  size: 100Gi\n  storageClassName: \"your-rwx-storage-class\"  # e.g., EFS, AzureFile, NFS\n</code></pre> <p>When <code>fileStorage.enabled: false</code> (the default), an ephemeral <code>emptyDir</code> is used and files are lost on pod restart.</p>"},{"location":"installation/kubernetes/#replay-storage-livekit-egress","title":"Replay storage (LiveKit egress)","text":"<p>The replay/clip capture feature requires LiveKit egress and the Kraken backend to share a storage volume for HLS segment access. Both the egress service and backend pods must be able to read and write to the same path. Enable a <code>ReadWriteMany</code> PVC:</p> <pre><code>replayStorage:\n  enabled: true\n  size: 50Gi\n  storageClassName: \"your-rwx-storage-class\"  # must be ReadWriteMany (e.g., EFS, AzureFile, NFS)\n</code></pre> <p>Configure your LiveKit egress to write segments to the same volume mounted at the backend's <code>REPLAY_EGRESS_OUTPUT_PATH</code>.</p>"},{"location":"installation/kubernetes/#secrets-management","title":"Secrets management","text":"<p>By default the chart creates a Kubernetes Secret from the values you provide. For production, use an external secret manager:</p> <pre><code>secrets:\n  existingSecret: \"my-pre-created-secret\"  # Helm won't create its own\n</code></pre> <p>The secret must contain: <code>JWT_SECRET</code>, <code>JWT_REFRESH_SECRET</code>, <code>LIVEKIT_API_SECRET</code>, and <code>REDIS_PASSWORD</code> (if using Redis auth).</p>"},{"location":"installation/kubernetes/#resources-and-autoscaling","title":"Resources and autoscaling","text":"<pre><code>backend:\n  resources:\n    requests: { cpu: 250m, memory: 512Mi }\n    limits: { cpu: 1000m, memory: 1Gi }\n  autoscaling:\n    enabled: true\n    minReplicas: 2\n    maxReplicas: 10\n    targetCPUUtilizationPercentage: 70\n\nfrontend:\n  resources:\n    requests: { cpu: 100m, memory: 128Mi }\n    limits: { cpu: 500m, memory: 256Mi }\n  autoscaling:\n    enabled: true\n    minReplicas: 2\n    maxReplicas: 5\n</code></pre>"},{"location":"installation/kubernetes/#operations","title":"Operations","text":""},{"location":"installation/kubernetes/#upgrading","title":"Upgrading","text":"<pre><code>helm upgrade kraken oci://ghcr.io/krakenchat/charts/kraken \\\n  --reuse-values \\\n  --set backend.image.tag=v1.1.0 \\\n  --set frontend.image.tag=v1.1.0 \\\n  --namespace kraken\n</code></pre>"},{"location":"installation/kubernetes/#rollback","title":"Rollback","text":"<pre><code>helm history kraken -n kraken\nhelm rollback kraken -n kraken        # previous version\nhelm rollback kraken 2 -n kraken      # specific revision\n</code></pre>"},{"location":"installation/kubernetes/#backup-mongodb","title":"Backup MongoDB","text":"<pre><code>kubectl exec -n kraken kraken-mongodb-0 -- \\\n  mongodump --uri=\"mongodb://localhost:27017/kraken\" \\\n  --gzip --archive=/tmp/backup.gz\n\nkubectl cp kraken/kraken-mongodb-0:/tmp/backup.gz ./backup.gz\n</code></pre>"},{"location":"installation/kubernetes/#restore-mongodb","title":"Restore MongoDB","text":"<pre><code>kubectl cp ./backup.gz kraken/kraken-mongodb-0:/tmp/backup.gz\n\nkubectl exec -n kraken kraken-mongodb-0 -- \\\n  mongorestore --uri=\"mongodb://localhost:27017/kraken\" \\\n  --gzip --archive=/tmp/backup.gz --drop\n</code></pre>"},{"location":"installation/kubernetes/#logs","title":"Logs","text":"<pre><code>kubectl logs -n kraken -l app.kubernetes.io/component=backend -f\nkubectl logs -n kraken -l app.kubernetes.io/component=frontend -f\n</code></pre>"},{"location":"installation/kubernetes/#troubleshooting","title":"Troubleshooting","text":"<p>For WebSocket and LiveKit connectivity issues, see the dedicated WebSocket Troubleshooting guide.</p>"},{"location":"installation/kubernetes/#pods-stuck-in-pending","title":"Pods stuck in Pending","text":"<pre><code>kubectl describe pod -n kraken &lt;pod-name&gt;\n</code></pre> <p>Common causes: insufficient resources, PVC not bound, image pull errors.</p>"},{"location":"installation/kubernetes/#database-connection-errors","title":"Database connection errors","text":"<pre><code>kubectl get pods -n kraken -l app.kubernetes.io/name=mongodb\nkubectl exec -it -n kraken deploy/kraken-backend -- sh -c 'mongosh \"$MONGODB_URL\"'\n</code></pre>"},{"location":"installation/kubernetes/#ingress-not-working","title":"Ingress not working","text":"<pre><code>kubectl describe ingress -n kraken\nkubectl logs -n ingress-nginx -l app.kubernetes.io/component=controller\n</code></pre>"},{"location":"installation/kubernetes/#production-checklist","title":"Production checklist","text":"<ul> <li> All default passwords and secrets changed</li> <li> TLS enabled via cert-manager or manual secret</li> <li> Resource limits and autoscaling configured</li> <li> External MongoDB with authentication (recommended over bundled)</li> <li> External Redis with authentication</li> <li> <code>ReadWriteMany</code> PVC for file storage</li> <li> LiveKit webhook URL configured</li> <li> Monitoring and alerting in place</li> <li> Backup strategy for MongoDB</li> <li> DNS configured for your domain</li> </ul>"},{"location":"operations/release-process/","title":"Release Process","text":"<p>Kraken uses a tag-based release workflow with support for full releases, component hotfixes, and manual builds.</p>"},{"location":"operations/release-process/#tag-patterns","title":"Tag Patterns","text":"Tag Pattern What it Triggers <code>v*.*.*</code> Full release: Electron + Docker + Helm + GitHub Release <code>electron-v*.*.*</code> Electron builds + GitHub Release only <code>docker-v*.*.*</code> Docker images to GHCR only <code>helm-v*.*.*</code> Helm chart to GHCR only"},{"location":"operations/release-process/#creating-a-release","title":"Creating a Release","text":""},{"location":"operations/release-process/#full-release","title":"Full Release","text":"<pre><code>git checkout main\ngit pull origin main\n\n# Update CHANGELOG.md, commit\ngit add CHANGELOG.md\ngit commit -m \"docs: update changelog for v1.0.0\"\n\n# Tag and push\ngit tag v1.0.0\ngit push origin main\ngit push origin v1.0.0\n</code></pre> <p>This triggers:</p> <ul> <li>Electron builds for Windows (.exe) and Linux (.AppImage, .deb, .rpm)</li> <li>Docker images published to GHCR (backend + frontend)</li> <li>Helm chart published to GHCR</li> <li>GitHub Release created with all Electron artifacts</li> <li>Auto-update manifests uploaded (latest.yml, latest-linux.yml)</li> </ul>"},{"location":"operations/release-process/#component-hotfixes","title":"Component Hotfixes","text":"<pre><code># Electron only\ngit tag electron-v1.0.1 &amp;&amp; git push origin electron-v1.0.1\n\n# Docker images only\ngit tag docker-v1.0.1 &amp;&amp; git push origin docker-v1.0.1\n\n# Helm chart only\ngit tag helm-v1.0.1 &amp;&amp; git push origin helm-v1.0.1\n</code></pre>"},{"location":"operations/release-process/#manual-build","title":"Manual Build","text":"<p>Go to GitHub Actions, select the workflow, click \"Run workflow\", optionally specify a version.</p>"},{"location":"operations/release-process/#release-artifacts","title":"Release Artifacts","text":""},{"location":"operations/release-process/#github-release-electron","title":"GitHub Release (Electron)","text":"Artifact Description <code>Kraken-Setup-X.X.X.exe</code> Windows NSIS installer <code>Kraken-X.X.X.AppImage</code> Linux universal binary <code>kraken_X.X.X_amd64.deb</code> Debian/Ubuntu package <code>kraken-X.X.X.x86_64.rpm</code> Fedora/RHEL package <code>latest.yml</code> / <code>latest-linux.yml</code> Auto-update manifests"},{"location":"operations/release-process/#docker-images-ghcr","title":"Docker Images (GHCR)","text":"<pre><code>ghcr.io/OWNER/kraken-backend:1.0.0\nghcr.io/OWNER/kraken-frontend:1.0.0\n</code></pre> <p>Tags: <code>1.0.0</code>, <code>1.0</code>, <code>1</code>, <code>latest</code></p>"},{"location":"operations/release-process/#helm-chart-ghcr-oci","title":"Helm Chart (GHCR OCI)","text":"<pre><code>helm install kraken oci://ghcr.io/OWNER/kraken/charts/kraken --version 1.0.0\n</code></pre>"},{"location":"operations/release-process/#electron-auto-update","title":"Electron Auto-Update","text":"<p>The desktop app checks for updates on startup (3s delay) and every hour. Uses GitHub Releases as the update source.</p> <p>Requirements: <code>latest.yml</code> must exist in the release, release must not be draft/prerelease.</p>"},{"location":"operations/release-process/#version-management","title":"Version Management","text":"<p>Versions are injected from git tags during CI -- no need to manually update <code>package.json</code> or <code>Chart.yaml</code>.</p> <p>Follow Semantic Versioning: MAJOR (breaking), MINOR (features), PATCH (fixes).</p>"},{"location":"operations/release-process/#troubleshooting","title":"Troubleshooting","text":"Issue Solution Auto-update not working Verify <code>latest.yml</code> exists in release, not draft/prerelease Build failures Check Actions logs, verify Node.js v20 compat Version mismatch Verify tag format matches expected patterns"},{"location":"operations/websocket-troubleshooting/","title":"WebSocket &amp; LiveKit Troubleshooting","text":"<p>Troubleshooting guide for Socket.IO WebSocket and LiveKit connectivity issues in Kubernetes deployments.</p>"},{"location":"operations/websocket-troubleshooting/#architecture","title":"Architecture","text":"<p>Kraken uses two types of real-time connections:</p> <ol> <li>Socket.IO WebSockets -- chat messages, presence, real-time updates</li> <li>LiveKit WebRTC -- voice/video calls and screen sharing</li> </ol> <pre><code>Client Browser\n    | WebSocket connection (with cookie affinity)\nIngress (NGINX)\n    | Routes to same pod via cookie\nBackend Pod A or Pod B\n    | Publishes messages to Redis\nRedis Pub/Sub\n    | Broadcasts to all backend pods\nAll Backend Pods -&gt; Emit to their connected clients\n</code></pre> <p>Key: Ingress cookie affinity keeps client connected to the same pod. Service-level affinity must be <code>None</code> so Redis can coordinate across pods.</p>"},{"location":"operations/websocket-troubleshooting/#common-issues","title":"Common Issues","text":""},{"location":"operations/websocket-troubleshooting/#messages-not-delivered","title":"Messages Not Delivered","text":"<p>Symptoms: Messages sent but not received, only visible to sender, intermittent delivery.</p> <p>Likely causes: Service-level <code>sessionAffinity: ClientIP</code> blocking Redis coordination, Redis adapter disconnected, missing ingress sticky sessions.</p>"},{"location":"operations/websocket-troubleshooting/#websocket-connection-fails","title":"WebSocket Connection Fails","text":"<p>Symptoms: Connection failed/timeout, stays as HTTP polling, 400/403/502 errors.</p> <p>Likely causes: Missing WebSocket upgrade annotations, auth issues, backend pods not ready.</p>"},{"location":"operations/websocket-troubleshooting/#livekit-datachannel-errors","title":"LiveKit DataChannel Errors","text":"<p>Symptoms: <code>Unknown DataChannel error on lossy/reliable</code>, <code>NotReadableError</code>.</p> <p>Likely causes: Same ingress issues as WebSocket, LiveKit server connectivity, firewall blocking UDP/WebRTC, missing browser permissions.</p>"},{"location":"operations/websocket-troubleshooting/#connection-drops-immediately","title":"Connection Drops Immediately","text":"<p>Symptoms: Connects then disconnects within seconds, \"ping timeout\" errors, repeated connect/disconnect cycles.</p> <p>Likely causes: Ingress timeout too short, service affinity issues, health checks interfering.</p>"},{"location":"operations/websocket-troubleshooting/#diagnostics","title":"Diagnostics","text":""},{"location":"operations/websocket-troubleshooting/#check-backend-pods","title":"Check Backend Pods","text":"<pre><code>kubectl logs -n kraken -l app.kubernetes.io/component=backend --tail=50 | \\\n  grep -i \"socket\\|redis\\|gateway\"\n</code></pre> <p>Expected: <pre><code>[RedisIoAdapter] Redis Socket.IO adapter configured successfully for multi-pod coordination\n[MessagesGateway] MessagesGateway initialized\n[PresenceGateway] PresenceGateway initialized\n</code></pre></p>"},{"location":"operations/websocket-troubleshooting/#check-redis","title":"Check Redis","text":"<pre><code>kubectl get pods -n kraken -l app.kubernetes.io/name=redis\nkubectl exec -it -n kraken deploy/kraken-backend -- sh -c 'nc -zv $REDIS_HOST $REDIS_PORT'\n</code></pre>"},{"location":"operations/websocket-troubleshooting/#check-ingress","title":"Check Ingress","text":"<pre><code>kubectl get ingress -n kraken -o yaml\n</code></pre> <p>Required annotations:</p> <pre><code>nginx.ingress.kubernetes.io/websocket-services: \"kraken-backend\"\nnginx.ingress.kubernetes.io/affinity: \"cookie\"\nnginx.ingress.kubernetes.io/session-cookie-name: \"kraken-affinity\"\nnginx.ingress.kubernetes.io/session-cookie-max-age: \"3600\"\nnginx.ingress.kubernetes.io/affinity-mode: \"persistent\"\nnginx.ingress.kubernetes.io/proxy-read-timeout: \"3600\"\nnginx.ingress.kubernetes.io/proxy-send-timeout: \"3600\"\n</code></pre>"},{"location":"operations/websocket-troubleshooting/#check-service-affinity","title":"Check Service Affinity","text":"<pre><code>kubectl get service -n kraken kraken-backend -o jsonpath='{.spec.sessionAffinity}'\n</code></pre> <p>Critical</p> <p>Must return <code>None</code>, not <code>ClientIP</code>. Service-level ClientIP affinity breaks Redis coordination across pods.</p>"},{"location":"operations/websocket-troubleshooting/#test-websocket-upgrade","title":"Test WebSocket Upgrade","text":"<pre><code>curl -i -N \\\n  -H \"Connection: Upgrade\" \\\n  -H \"Upgrade: websocket\" \\\n  -H \"Sec-WebSocket-Version: 13\" \\\n  -H \"Sec-WebSocket-Key: test\" \\\n  https://your-domain.com/socket.io/?EIO=4&amp;transport=websocket\n</code></pre> <p>Expected: <code>HTTP/1.1 101 Switching Protocols</code></p>"},{"location":"operations/websocket-troubleshooting/#solutions","title":"Solutions","text":""},{"location":"operations/websocket-troubleshooting/#fix-service-session-affinity","title":"Fix Service Session Affinity","text":"<pre><code>kubectl get service -n kraken kraken-backend -o yaml | grep sessionAffinity\n# If \"ClientIP\", upgrade Helm chart:\nhelm upgrade kraken ./helm/kraken -n kraken --reuse-values\nkubectl rollout restart deployment/kraken-backend -n kraken\n</code></pre>"},{"location":"operations/websocket-troubleshooting/#add-missing-ingress-annotations","title":"Add Missing Ingress Annotations","text":"<p>Update <code>values.yaml</code> with the annotations listed above, then:</p> <pre><code>helm upgrade kraken ./helm/kraken -n kraken --reuse-values\n</code></pre>"},{"location":"operations/websocket-troubleshooting/#fix-redis-connection","title":"Fix Redis Connection","text":"<pre><code>kubectl get secret -n kraken kraken-redis -o jsonpath='{.data.redis-password}' | base64 -d\n# Verify password matches backend ConfigMap, restart if needed:\nkubectl rollout restart deployment/kraken-backend -n kraken\n</code></pre>"},{"location":"operations/websocket-troubleshooting/#fix-livekit-browser-permissions","title":"Fix LiveKit Browser Permissions","text":"<ol> <li>Verify HTTPS is enabled (required for WebRTC)</li> <li>Check browser permissions for microphone/camera</li> <li>Close other apps using the device</li> <li>Try a different browser</li> </ol>"},{"location":"operations/websocket-troubleshooting/#verification","title":"Verification","text":"<ol> <li>Browser DevTools -&gt; Network -&gt; Filter \"WS\" -&gt; look for <code>101 Switching Protocols</code></li> <li>Open two windows with different users, send a message, verify delivery</li> <li>With multiple replicas: Send message from user on Pod A, verify user on Pod B receives it</li> <li>Check cookies: Application tab -&gt; look for <code>kraken-affinity</code> cookie</li> </ol>"},{"location":"operations/websocket-troubleshooting/#pre-deployment-checklist","title":"Pre-Deployment Checklist","text":"<ul> <li> Ingress has all required WebSocket annotations</li> <li> Service has <code>sessionAffinity: None</code></li> <li> Redis is deployed and accessible</li> <li> Backend pods log \"Redis Socket.IO adapter configured successfully\"</li> <li> HTTPS/TLS is enabled (required for WebRTC)</li> <li> Tested with 2+ backend replicas</li> <li> Tested message delivery between users on different pods</li> <li> Tested voice/video calls with LiveKit</li> </ul>"}]}